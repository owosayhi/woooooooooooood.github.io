<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ds-5</title>
    <link href="/2022/05/05/ds-5/"/>
    <url>/2022/05/05/ds-5/</url>
    
    <content type="html"><![CDATA[<p>到了我们<del>知识点暴多</del>快乐的树啦</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>树大概长这样</p><p><img src="./ds-5/TreeExample.png"></p><p>一棵无拘无束的<strong>树</strong>（也就是最广义的树），有以下特点：</p><ol><li>两个节点之间，有且只有一条边</li><li>n个节点必然有n+1条边。（思考后你会发现，如果删去树的任意一条边，这个树就会断开）</li><li>树没有回路（想想现实当中的树，不会有树枝长到自己身体里）</li><li>其实没有回路的无向图就可以被当做树</li></ol><p>而<strong>二叉树</strong>，则是固定了子节点最多为2的树。</p><p>于是又衍生出以下定义：</p><p><strong>满二叉树</strong>：深度为h 且有2^h-1个节点的二叉树。</p><p><strong>完全二叉树</strong>：1-h层满，h层从右往左有所缺失</p><p><strong>斜树</strong>：左斜树、右斜树，看上去就和线性表一样</p><p>在未来的《离散数学》课本当中，二叉树可能会被天杀的定义成满二叉树……所以要是拿树的知识点做题……就需要有联系上下文的能力。</p><h2 id="树的转化"><a href="#树的转化" class="headerlink" title="树的转化"></a>树的转化</h2><h3 id="普通的树–-gt-二叉树"><a href="#普通的树–-gt-二叉树" class="headerlink" title="普通的树–&gt;二叉树"></a>普通的树–&gt;二叉树</h3><p>而一颗肆无忌惮的树转化成二叉树，有这么一种标准的方法：</p><p><img src="./ds-5/tree2erchatree.png"></p><p>注意，这个转化的思想感觉有很多的可操作的空间，比如：凭什么同一层兄弟们，偏偏是最左边的那个节点做爸爸呢？我偏偏要让最右边的做爸爸也可以呀！</p><p>但是这个方法是一个业内的标准做法，这个当爸爸的顺序建议记住，考试会把它当做默认已知的构造方式，而不告诉你同一层的兄弟谁做爸爸。</p><h3 id="二叉树–-gt-森林"><a href="#二叉树–-gt-森林" class="headerlink" title="二叉树–&gt;森林"></a>二叉树–&gt;森林</h3><p>这个构造的顺序也是页内标准做法，建议记住，填选会考。</p><p><img src="./ds-5/ercha2forest.png"></p><h1 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h1><h2 id="结构体写树"><a href="#结构体写树" class="headerlink" title="结构体写树"></a>结构体写树</h2><p>和之前学的链表有点像，只不过，连向其他节点的指针，由一个变成了两个乃至很多个。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>* <span class="hljs-title">child</span>[5];</span><br>&#125;head;<span class="hljs-comment">//比如这是一个儿子数上限为5的树节点。</span><br></code></pre></td></tr></table></figure><p>二叉树由于其性质不太一样，一般管它左右两个儿子叫<code>lchild</code>和<code>rchild</code>。图省事叫它<code>l</code>和<code>r</code>也可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">lchild</span>,<span class="hljs-title">rchild</span>;</span><br>&#125;head;<span class="hljs-comment">//这是一个二叉树的节点</span><br></code></pre></td></tr></table></figure><p>这里就有一棵朴实无华的，用结构体写成的二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//当树的性状不确定，用数组 装 树 会太大时，考虑用结构体写树</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>//定义树的节点结构体</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> have_value;<span class="hljs-comment">//判断是否有值，用于判断在写树的时候有没有重复写</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span><span class="hljs-comment">//指向左边和右边的指针，注意写法</span><br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">node</span>[1000];</span><span class="hljs-comment">//创建，序号无含义</span><br><span class="hljs-type">char</span> s[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//用来计数，第几个节点</span><br><span class="hljs-type">int</span> error=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> Node * <span class="hljs-title function_">newnode</span><span class="hljs-params">()</span><span class="hljs-comment">//创建节点，返回值是节点结构的指针</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">u</span>=</span>&amp;node[cnt++];<br>    u-&gt;left=<span class="hljs-literal">NULL</span>;<br>    u-&gt;right=<span class="hljs-literal">NULL</span>;<br>    u-&gt;value=<span class="hljs-number">0</span>;<br>    u-&gt;have_value=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">addnode</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>)</span><span class="hljs-comment">//这个地方是根据scanf进来的插入路径，插入新的节点。</span><br>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">u</span>=</span>&amp;node[<span class="hljs-number">0</span>];<span class="hljs-comment">//先指向根节点再往下走</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(u-&gt;left==<span class="hljs-literal">NULL</span>)<span class="hljs-comment">//左边没有节点</span><br>            u-&gt;left=newnode();<br>            u=u-&gt;left;<span class="hljs-comment">//向下走</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(u-&gt;right==<span class="hljs-literal">NULL</span>)<br>            u-&gt;right=newnode();<br>            u=u-&gt;right;<span class="hljs-comment">//向下走</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(u-&gt;have_value==<span class="hljs-number">1</span>)<br>    error=<span class="hljs-number">1</span>;<span class="hljs-comment">//判断有重复写节点</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        u-&gt;value=v;<span class="hljs-comment">//赋值</span><br>        u-&gt;have_value=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    newnode();<span class="hljs-comment">//要先创造根节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>        <span class="hljs-built_in">sscanf</span>(&amp;s[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;%d&quot;</span>,&amp;value);<span class="hljs-comment">//(写的时候写作：（12,LLR）)</span><br>        addnode(value,<span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">&#x27;,&#x27;</span>+<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,node[i].value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用数组写二叉树"><a href="#用数组写二叉树" class="headerlink" title="用数组写二叉树"></a>用数组写二叉树</h2><p>与模拟结构体一样，我们也可以<strong>用数组的下标指针换成目标结构</strong>。而在前面的图中，我们也发现了：</p><p><img src="./ds-5/TreeExample.png"></p><ol><li>父亲序号*2 == 左儿子序号</li><li>父亲序号*2 + 1 == 右儿子序号</li></ol><p>所以一个粗暴的数组就可以表示树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> tree[<span class="hljs-number">10000</span>];<br></code></pre></td></tr></table></figure><p>为了区分真实存在的节点，和其实是NULL的节点，一般我们把<code>tree[]</code>中的每一个元素赋值为一个真正的节点不会出现的值（比如：假设规定所有节点的值<code>data</code>都是非负数，那我们在初始化时，将所有节点的值赋值为-1，表示该节点是NULL）。</p><h2 id="奇形怪状的树"><a href="#奇形怪状的树" class="headerlink" title="奇形怪状的树"></a>奇形怪状的树</h2><p>比如第四次作业那道不计分的题目，其实可以用这棵树</p><p><img src="ds-5/weirdTree.png"></p><p>如果用孩子兄弟表示法去写树，那么这棵树很意外地将一棵广义的树，写成了一棵二叉树的样子。</p><p><img src="ds-5/broTree.png"></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树有以下几种遍历方式：</p><ol><li>前序遍历：若树为空，则空操作返回，否则先访问根节点，然后遍历左子树，然后遍历右子树</li></ol><p><strong>（中，左，右）</strong></p><ol start="2"><li>中序遍历：若树为空，则空操作返回，否则从根节点开始遍历左子树，然后访问根节点，然后遍历右子树</li></ol><p><strong>（左，中，右）</strong></p><ol start="3"><li>后序遍历：若树为空，则空操作返回，否则从根节点开始，遍历左子树，然后遍历右子树，然后访问根节点</li></ol><p><strong>（左，右，中）</strong></p><p>4）层序遍历：若树为空，则空操作返回，否则从根节点开始，从左往右向下一行一行遍历</p><h1 id="树的线索化"><a href="#树的线索化" class="headerlink" title="*树的线索化"></a>*树的线索化</h1><p>树的线索化即：将叶结点中没有用上的值为<code>NULL</code>的指针用上，拿来指向按照遍历顺序的下一个/上一个节点。以此，实现指针的充分利用。</p><p>首先，需要线索化的树的结构体有一些变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-type">int</span> ltag,rtag;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里面多了<code>ltag</code>和<code>rtag</code>，这两个变量是用来<strong>标记这个结点的左右指针，是构成树的指针，还是被利用了起来的空指针</strong>。之所以需要标记，是因为我们希望在一棵树线索化之后，我们还是可以清楚地知道哪个节点是叶子节点。如果我们以后还想在叶子节点后面加节点，就不至于找不到实则儿子为NULL的叶结点了。</p><p><img src="ds-5/threadingTreeDeclear.png"></p><p>而实现线索化的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">pre</span>=</span><span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">threading</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *head)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(head!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        threading(head-&gt;left);<br>        <span class="hljs-keyword">if</span>(!head-&gt;left)<br>        &#123;   <br>            head-&gt;ltag=<span class="hljs-number">1</span>;<br>            head-&gt;left=pre;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!pre-&gt;right)<br>        &#123;<br>            pre-&gt;rtag=<span class="hljs-number">1</span>;<br>            pre-&gt;right=head;<br>                    &#125;<br>        pre=head;<br>        threading(head-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式只是把空指针利用起来了，而没有改变树的结构。且由于tag的存在，我们可以分辨哪些指针原本是空指针，从而继续加叶子。</p><p>下面将展示的，是如何遍历线索化的树。由于代码源自一本书，所以变量名的设置可能和本人不太一样，比如它将<code>struct node *</code>写为了<code>BiThrTree</code>。</p><p>接下来是遍历线索树的代码和解析：</p><p><img src="ds-5/threadingTreeCode.png"></p><p><img src="ds-5/threadingTreeNote.png"></p><h1 id="树的路径长度、带权路径长度-与-赫夫曼树"><a href="#树的路径长度、带权路径长度-与-赫夫曼树" class="headerlink" title="树的路径长度、带权路径长度 与 赫夫曼树"></a>树的路径长度、带权路径长度 与 赫夫曼树</h1><p>我们已知，当我们用树的时候，一棵树只有树的树根（或者叫<code>head</code>节点）是暴露给我们的。当我们想对树进行查找的时候，只能从树根（头节点）开始，往下一步一步地找。</p><p>于是查找的性能就“因树而异”了：可能这棵树长得挺平衡，找每个结点的复杂度都差不多；也可能这棵树所有的结点都只有右结点，导致要找那个唯一的叶子结点要跑天远。</p><p>我们知道，n个节点的数就有n-1条边。但是n-1这个数，不足以衡量一棵树到底是否方便查找。</p><p>那很自然地就想到：让距离头结点较远的节点，在计算树的“长度”时，具有更大的权重。于是我们引入概念：<strong>树的路径长度</strong>，即<strong>树的路径长度是从树根到树中每一结点的路径长度之和。</strong>。</p><p>简单推算就会有这样一条结论：在结点数目相同的二叉树中,完全二叉树的路径长度最短。这符合我们刚才的设想：一棵看上去很均衡的树比较方便查找。</p><p>但是，如果我们访问每一个节点的频率是不一样的呢？比如某一个我经常找的节点，把它放在头节点附近，肯定比放在很远的地方要更好。那“访问的频率”这一信息我们怎么考虑进去呢？</p><p>那很自然地就引出了<b>如何去衡量一棵树到底是不是一颗好查找的树</b>的问题。我们的答案是：<strong>树的带权路径长度（WPL）</strong>，即<strong>为每个叶节点设置一个权重。树的带权路径长度，即为树中所有叶子节点的带权路径长度之和</strong>。让距离头节点的节点，具有更高的权重。这样一来，我们就可以说：<strong>树的带权路径长度（WPL）</strong>较小的树，是一颗货真价实的好找的树了。</p><p>这里给出一个求带权路径长度的例子：（用树，去记录不同等级成绩的同学的数量）</p><p><img src="ds-5/WPL_example.png"></p><p>特别注意，在计算树的带权路径长度时，每个节点的权值到底是乘几（比如图中“优”的权值应该乘几呢？）。这一点很容易在考试的时候忘掉，注意记住。</p><p>问题来了，我们手上有一群带有各自权重的叶子结点，怎么拼才能把它们拼成一棵最方便查找的树呢？</p><p>结论就是我们亲爱的：</p><h2 id="赫夫曼树（哈夫曼树）"><a href="#赫夫曼树（哈夫曼树）" class="headerlink" title="赫夫曼树（哈夫曼树）"></a>赫夫曼树（哈夫曼树）</h2><p>赫夫曼树是理论上带权路径长度最低的树，如果你有兴趣，这个知识点或许可以用在大作业当中，提高代码的性能。</p><p>赫夫曼树的构造方法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>) 把每个数据变成一个独立的结点，并记录权重<br><span class="hljs-selector-tag">b</span>) 创建空结点，取权重最低的两棵树，把他们作为左右结点<br>c) 这个树的根结点成为需要被比较的结点，其权重为两个子结点权重之和<br>d) 循环<span class="hljs-selector-tag">b</span>、c<br></code></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集主要的功能是：</p><ol><li>看看森林当中的两个节点是不是在一棵树上</li><li>看看森林当中到底有几个节点</li></ol><p>如果形象地说就是，在一群地痞流氓当中：</p><ol><li>看看两个人是不是属于同一个头头</li><li>看看场上到底有几个帮派</li></ol><p>给出查并集的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> belong[<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//先初始化，每个人的头头是自己</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        belong[i] = i;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_belong</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">//得到人的头头</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (belong[x] == x)                    <span class="hljs-comment">//如果自己是头儿</span><br>        <span class="hljs-keyword">return</span> x;                          <span class="hljs-comment">//告诉别人自己是头儿</span><br>    <span class="hljs-keyword">else</span>                                   <span class="hljs-comment">//如果自己不是头儿</span><br>        belong[x] = get_belong(belong[x]); <span class="hljs-comment">//找到自己的头儿，顺便订正自己的头儿</span><br>    <span class="hljs-keyword">return</span> belong[x];                      <span class="hljs-comment">//告诉别人自己的头儿</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">conbine</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><br>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    x = get_belong(left);<br>    y = get_belong(right);<br>    <span class="hljs-keyword">if</span> (x != y)<br>    &#123;<br>        belong[y] = x; <span class="hljs-comment">//这里不应该改right的belong，而是改y这个right的头头的，这样就可以去掉一个头头，而right到底属于谁是不重要的，反正确定他不是老大就可以了</span><br>        <span class="hljs-comment">//这里x y谁跟谁都一样</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, left, right, sum = <span class="hljs-number">0</span>, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">//得到人数和信息数</span><br>    init(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;left, &amp;right); <span class="hljs-comment">//得到每一条有关“关联”的信息</span><br>        conbine(left - <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">//统计没有依靠别人的人数，即为头头数，即为组织数</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (belong[i] == i)<br>            sum++;<br>    &#125;<br>    <span class="hljs-comment">//如果希望找到真正头头的话，需要让所有人再确认一下自己的大哥，免得有时大哥跟别人了，小弟还不知道。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        get_belong(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d belong to %d\n&quot;</span>, i, belong[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，市面上同一功能的代码，一般不这么命名。一般会<br>将我代码中的:</p><p><code>int belong[1000]</code>叫成<code>int parent[1000]</code></p><p><code>get_belong</code>叫成<code>find</code></p><p><code>conbine</code>叫成<code>merge</code></p><h1 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="*平衡二叉树（AVL树）"></a>*平衡二叉树（AVL树）</h1><p>平衡二叉树的出现，出于这样一个希望：</p><p>如果二叉树在一个一个加节点构建的时候，自动根据左右子树的“重量”去修改连接方式，于是随时保持其左右子树差不多高（高度差&lt;=1）就好了。</p><p>所以我们这样定义平衡二叉树：<strong>每个结点的左子树和右子树高度差&lt;=1的二叉树</strong></p><p>引入概念<strong>平衡因子BF</strong>==左子树深度-右子树深度。这一参数需要加入二叉树的属性当中，也就是说，我们的节点定义变成了这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> BF;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>延伸概念：<strong>最小不平衡子树</strong>：假如新插入了一个结点，则距离插入结点最近的、平衡因子绝对值&gt;1的子树</p><p>那我们怎么实现平衡二叉树呢？答案是<strong>左旋</strong>与<strong>右旋</strong></p><p><img src="ds-5/balanceTree.png"></p><p>如图所示，当左右子树的高度差&gt;=2时，有上面的四种情况。我们针对这四种情况发明一个处理方法，我们就可以保持二叉树的平衡啦。</p><h1 id="上机题目"><a href="#上机题目" class="headerlink" title="上机题目"></a>上机题目</h1><h2 id="树叶节点遍历"><a href="#树叶节点遍历" class="headerlink" title="树叶节点遍历"></a>树叶节点遍历</h2><p>题目实际上是在建立一颗二叉排序树</p><p>排序二叉树的构建如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;head-&gt;data);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>&#123;<br>    p = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    p-&gt;r = <span class="hljs-literal">NULL</span>;<br>    p-&gt;l = <span class="hljs-literal">NULL</span>;<br>    q = head;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;data &lt; q-&gt;data)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;l == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                q-&gt;l = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            q = q-&gt;l;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;r == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                q-&gt;r = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            q = q-&gt;r;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>树的中序遍历代码大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *t)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//到头了，刹住车</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>    <span class="hljs-comment">//先左</span><br>    traverse(t-&gt;lchild);<br>    <span class="hljs-comment">//再中</span><br>    <span class="hljs-keyword">if</span> (t-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; t-&gt;rchild == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//满足一定的条件（可以改成自己的条件）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, t-&gt;data);                  <span class="hljs-comment">//对该节点（可以改成自己的操作）</span><br>    <span class="hljs-comment">//后右</span><br>    traverse(t-&gt;rchild);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这道题其实什么序遍历都可以。</p><h2 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h2><p>这道题和上一题几乎一样，只不过是将<code>int</code>的<code>data</code>换成了字符串；将<code>int</code>的大小换成了字符串的字典序大小；将每进来一个节点都变成叶子节点，变成了：如果这个单词出现过，那这个词的频率增加。如果这个单词没出现过，那就造一个叶子结点。</p><p>这里给出构造树的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *p)</span><br>&#123;<br>    q = head;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;c, p-&gt;c) &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;l != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                q = q-&gt;l;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q-&gt;l = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;c, p-&gt;c) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;r != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                q = q-&gt;r;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q-&gt;r = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            q-&gt;time++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算器（表达式树实现）"><a href="#计算器（表达式树实现）" class="headerlink" title="计算器（表达式树实现）"></a>计算器（表达式树实现）</h2><p>这个题的一大思维障碍就是：这棵树不是从一个固定的根节点开始构建的，而是从底部慢慢往上面构建的。</p><p>我们在上一次上机学会了怎么用栈，完成带括号的表达式计算（学会了……吧？）。</p><p>让我们模拟一个和题干长得差不多的树的建立</p><p><img src="ds-5/expTree.png"></p><p>为什么不用题干的表达式呢，因为题干的表达式太多括号了，画起来麻烦……</p><p>如图所示为一个符号栈，和一个数字栈。和之前符号栈出来就马上及时计算不同，我们保留了这个符号，并把它变成了一个新的节点放回了栈中。我们只需将之前所学的用栈解决表达式的方法类比过来就好啦。</p><p>你可能会困惑，如何让节点有时候表示符号，有时候表示数字呢。</p><p>我们可以这样定义节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-type">char</span> sign;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;<br><span class="hljs-comment">//当flag == 0 时，这个节点是一个数字节点，num存储着数字；sign的数值无意义，不访问就好。</span><br><span class="hljs-comment">//当flag == 1 时，这个节点是一个符号节点，sign存储着符号；num的数值无意义，不访问就好。</span><br></code></pre></td></tr></table></figure><p>当flag</p><p>至于怎么计算呢，就对当前头结点调用一个函数（不如叫它<code>func</code>吧）。大概如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (n-&gt;flag == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> n-&gt;num;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n-&gt;flag == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n-&gt;sign == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">return</span> func(n-&gt;lchild) + func(n-&gt;rchild);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n-&gt;sign == <span class="hljs-string">&#x27;-&#x27;</span>)<br>            <span class="hljs-keyword">return</span> func(n-&gt;lchild) - func(n-&gt;rchild);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n-&gt;sign == <span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">return</span> func(n-&gt;lchild) * func(n-&gt;rchild);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n-&gt;sign == <span class="hljs-string">&#x27;/&#x27;</span>)<br>            <span class="hljs-keyword">return</span> func(n-&gt;lchild) / func(n-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO-unit2</title>
    <link href="/2022/05/01/OO-unit2/"/>
    <url>/2022/05/01/OO-unit2/</url>
    
    <content type="html"><![CDATA[<h1 id="同步块的设置"><a href="#同步块的设置" class="headerlink" title="同步块的设置"></a>同步块的设置</h1><p>本单元的基本架构由以下三个主要部分组成：</p><ol><li>Inputhander：用来接收、分类输入，是线程。</li><li>Controller：用来处理输入、处理结束、是共享对象。</li><li>Elevator、Conveyer：电梯本身，用来接送乘客，是线程。</li></ol><p>出于输出线程安全的考虑，再外加一个Outputer的单例对象，用于处理所有的输出。</p><p>因此，在共享对象（也就是Controller、Outputer）涉及数据读写的方法上，加上<code>synchronized</code>进行修饰，即可实现线程安全。</p><h1 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h1><h2 id="look算法"><a href="#look算法" class="headerlink" title="look算法"></a>look算法</h2><p>采用look算法。基本逻辑如下：</p><ol><li>检查是否需要开门。如果需要，则开门接/放客。</li><li>检查电梯上的所有人与该电梯所在的等待队列中的所有乘客，看电梯运行方向的<b> 前方</b>是否有接/放客的请求。若有，则保持原方向。若无，则调转方向。</li><li>沿着第二步处理过后的方向，前进一层，并回到第一步。</li></ol><h2 id="look算法的小bug"><a href="#look算法的小bug" class="headerlink" title="look算法的小bug"></a>look算法的小bug</h2><p>但是到了第二次作业，引入了自由竞争后，就会出现bug，如：</p><p>电梯1与电梯2都在A座的第一层。此时A座1层进入一个乘客，电梯1、2随机都开门抢课。不妨设电梯1抢到了该乘客。则此时对电梯2，在look算法的第二步中，检查发现上方并没有请求，则该电梯就会将方向改为朝下。于是在第三步就进入了第0层。</p><p>解决方法就是：对“在最底层向下走”和“最高层向上走”的两种情况进行特判，阻止电梯走到0层与11层。</p><h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p>采用的基本架构或许可以叫做生产者－消费者模式吧。</p><h2 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h2><p>类图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202205/2785182-20220501175158036-110525073.jpg"></p><p>大致思路是：把<code>PersonRequest</code>类作为乘客本身，当输入一个<code>PersonRequest</code>时，<code>InputHandler</code>就会访问<code>Controller</code>的<code>HashMap&lt;Character, ArrayList&lt;PersonRequest&gt;&gt; map</code>，并将<code>PersonRequest</code>放到对应楼座的<code>ArrayList</code>当中。而电梯，则定期到<code>Controller</code>当中，查找自己对应楼座的<code>ArrayList</code>以判断是否开门接客、是否调转方向。当电梯需要接客时，则将<code>PersonRequest</code>从<code>Controller</code>的<code>ArrayList</code>中删除，并将其加入到<code>Elevator</code>中的<code>ArrayList&lt;PersonRequest&gt; passengers</code>当中。当需要开门放客时，遍历自己的<code>ArrayList&lt;PersonRequest&gt; passengers</code>，将请求的目的地楼层与当前楼层相同的请求删去，并进行相应的输出即可。</p><p>此时考虑到后续必然会加电梯，所以将等待的乘客统一放在共享对象<code>Controller</code>中而非电梯中，电梯内部的乘客放在<code>Elevator</code>类中，就是出于对自由竞争机制的预备。<br>##　第二次作业<br>对纵向的电梯，采用了自由竞争的策略。<br>类图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202205/2785182-20220501175214119-1773963039.jpg"></p><p>为了能够充分利用之前的代码，将横向电梯设置为一个新的类<code>Conveyer</code>，并复用<code>HashMap&lt;Character, ArrayList&lt;PersonRequest&gt;&gt; map</code>，将横向电梯的key设置为其所在楼层对应的字符，原理近乎相同。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>笔者试图在横向电梯中使用look算法，设置的机制如下：</p><ol><li>检查是否需要开门。如果需要，则开门接/放客。</li><li>检查电梯上的所有人与该电梯所在的等待队列中的所有乘客，看电梯运行方向的<b> 前方的两个座</b>是否有接/放客的请求。若有，则保持原方向。若无，则调转方向。</li><li>沿着第二步处理过后的方向，前进一层，并回到第一步。</li></ol><p>由此实现了横向电梯的伪look算法。</p><h2 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>受到第四次课上实验_第二部分的启示，采用了流水线模式。</p><p>对于需要处理成多段请求的人，设计为了一个<code>Person</code>类，然后对<code>Person</code>进行删除请求、获取请求的操作。</p><p>类图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202205/2785182-20220501175235489-161897498.jpg"></p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>设想一种情况：有一位需要多次换乘的乘客，若他第一程下电梯后，下一程的电梯能提前来接他，那耗时一定能压缩到最小。</p><p>基于这一想法，考虑实现让电梯提前来接乘客，方法就是：每输入一个乘客，就在需要换乘的上电梯处放置一个0号虚空请求（根据题设，乘客id必须&gt;0，所以id==0的请求视为虚空请求就再合适不过了），让电梯前往换乘点。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PersonRequest</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonRequest</span>(floor, floor, <br>    request.getFromBuilding(), request.getToBuilding(),<br>        request.getPersonId());<br><span class="hljs-type">PersonRequest</span> <span class="hljs-variable">p02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonRequest</span>(floor, floor,<br>    request.getFromBuilding(), request.getToBuilding(),<br>        <span class="hljs-number">0</span>);<br>map.get((<span class="hljs-type">char</span>) (floor + <span class="hljs-string">&#x27;0&#x27;</span>)).add(p02);<br>person.addRequest(p2);<br><span class="hljs-keyword">if</span> (request.getToFloor() != floor) &#123;<br>    <span class="hljs-type">PersonRequest</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonRequest</span>(floor,<br>        request.getToFloor(), request.getToBuilding(),<br>            request.getToBuilding(), request.getPersonId());<br>    <span class="hljs-type">PersonRequest</span> <span class="hljs-variable">p03</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonRequest</span>(floor, <br>        request.getToFloor(), request.getToBuilding(),<br>            request.getToBuilding(), <span class="hljs-number">0</span>);<br>    person.addRequest(p3);<br>    map.get(request.getToBuilding()).add(p03);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于0号请求的存在，电梯会将其当成一般的请求处理，在一定情况下，会提前抵达0号请求所在的楼层/楼座。只需要在原先的<code>getRequest</code>电梯/传送带检查正在等待的<code>PersonRequest</code>的<code>ArrayList</code>中，加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (map.get(name).get(i).getPersonId() == <span class="hljs-number">0</span> <br>    &amp;&amp; floor == map.get(name).get(i).getFromFloor()) &#123;<br>    map.get(name).remove(i);<br>    i--;<br>&#125;<br></code></pre></td></tr></table></figure><p>即可防止0号乘客虚空上电梯，并悄悄地让电梯提前到了中转的楼层/楼座等待需要换乘的乘客。</p><p>但是，如果电梯正在运行当中，加入中转的0号请求，可能会导致电梯跑老了大老远结果是虚空接客，让这一优化成为负优化。于是，在乘客进入电梯的方法中，加入以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (p.getPersonId() == <span class="hljs-number">0</span>) &#123;<br>    waitQueue.remove(i);<br>    i--;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写还有一个好处，就是可以防止：如果0号请求是在电梯<code>getRequest</code>之后、正式上客之前加入的，就有可能0号请求进入电梯的bug。</p><h2 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h2><p>考虑到第三次作业完全覆盖了前两次作业的功能，不妨直接使用第三次作业的协作图表示该单元的总体的线程之间的协作关系。</p><p>协作图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202205/2785182-20220501175245413-1214593076.jpg"></p><h3 id="结束机制"><a href="#结束机制" class="headerlink" title="结束机制"></a>结束机制</h3><p>在第一、二次作业当中，电梯结束的方法为：如果电梯在访问自己的等待乘客列表时，发现输入结束、电梯为空且等待列表也为空，则结束电梯进程。</p><p>但是这一判断方式在第三次作业中会出问题，因为乘客请求在到达换乘的下一站之前，并不会及时出现在旅程中段电梯的等待列表中，电梯一旦空了，就会误以为自己以后已经没有任务而结束（事实上还有一个乘客在换乘中，在来搭电梯的路上）。于是线程结束的机制，索性改成：所有的<code>Person</code>都已完成即可。</p><h1 id="程序bug"><a href="#程序bug" class="headerlink" title="程序bug"></a>程序bug</h1><p>该单元的bug比之前要多了，由于整个电梯的框架还是很清晰的，所以哪里出问题了一看报错就能发现，很多都是一目了然的小问题。但bug的出现还是远多于与其，主要原因还是因为自己没有写评测机，对自己的电梯也只做了逻辑运行正确性上的测试，而没有在复杂的运行状态下做充分的测试造成的。</p><p>以下将对每次作业出的bug进行分析。<br>##　第一次作业<br>忘记在满员的情况下，电梯根本没必要再检查是否需要开门接客。例如电梯载满乘客从5楼走到1楼，期间每一层都有人在外面等电梯。我的电梯就会在到达的每一层都发现需要开门接客，于是就白白开门关门，徒增运行时间导致TLE。</p><p>修改也很简单，在开门前加一层判断，如果没有人要下电梯，且电梯满员，则不开门即可。</p><h2 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h2><p>在调度器设计那一栏提到了第二次作业，对自由竞争导致的“在最底层向下走”和“最高层向上走”进行了特判，但是忘记把打印“ARRIVE”也加入特判当中了，导致出现了从1层arrive到1层的情况。这一点肉眼没法发现，评测机却会抓出来……</p><p>修改也很简单，如果发生了特判的情况，则不打印即可。</p><h2 id="第三次作业-1"><a href="#第三次作业-1" class="headerlink" title="第三次作业"></a>第三次作业</h2><p>在共享对象controller里面放一个map，key为楼层，value为第二层map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Integer, HashMap&lt;Character, Boolean&gt;&gt; permits;<br></code></pre></td></tr></table></figure><p>第二层map，key为楼座，value为记录这层的电梯可否在此座开门的boolean值。</p><p>每加入一个电梯，就获取它所在楼层的map，如果这个电梯能在楼座X开门，则将map中key为X的值置true。</p><p>乘客寻找需要在哪层换乘时，只需要看controller中每一层的map，看看目标楼座和出发楼座的value是否为true，若是，则该乘客在此层换乘。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果在同一层，出现两个横向电梯，分别允许在：</p><p>A B</p><p>A  C</p><p>开门，则A/B/C的value会被置true，需要从B到C的乘客就会在这一层换乘，然而没有电梯能够从B走到C，于是没有电梯接收这一乘客。</p><h3 id="修改方式"><a href="#修改方式" class="headerlink" title="修改方式"></a>修改方式</h3><p>在共享对象controller里面的map，key仍为楼层，value为第二层map构成的ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Integer, ArrayList&lt;HashMap&lt;Character, Boolean&gt;&gt;&gt; permits;<br></code></pre></td></tr></table></figure><p>而第二层map的含义，则变为key为楼座，value 为<b>该电梯</b>可在此楼座开门的标志boolean。</p><p>乘客寻找需要在哪层换乘时，改为看controller中每个楼层的ArrayList的每个map，在map当中同时满足目标楼座和出发楼座的value均为true，才选择在此座换乘。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>电梯设计最大的收获大概就是第一次接触线程安全问题吧。不得不说直接使用<code>synchronized</code>是个很偷懒的方法，直接在两个线程的共享对象中，将所有方法用<code>synchronized</code>上锁，就能够保证每次只有一个线程在访问这一共享对象。</p><p>由于线程安全问题涉及到多个线程访问某一对象的先后问题，故架构设置得越简单，越有利于捋清线程安全的思路。</p><h2 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h2><p>SRP： 类的职责应当单一。</p><p>OCP：尽量少地修改已有的实现，并通过增加方法、增加特判来实现新功能。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一个最大的感受就是，要相信计算机的性能，具体体现在：该for循环就for循环，该遍历就遍历，哪怕经常要遍历ArrayList想着挺别扭。一开始的时候，总想着用HashMap做到O(1)的搜索，但是一顿尝试之后，发觉现代计算机的算力真的很强，遍历ArrayList慢不到哪去。哪怕有一堆线程在等某一线程对着共享对象一通遍历，但这也用不了多久，放心交给电脑，它算的很快。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 第四次上机</title>
    <link href="/2022/04/21/ds-4/"/>
    <url>/2022/04/21/ds-4/</url>
    
    <content type="html"><![CDATA[<p>这一节的内容很重要，所以非常建议大家按照指定的数据结构写题。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈，可以理解为一个汉诺塔，只能从最上方增加、拿走一个数据。</p><p>所以栈的操作无非两个：</p><ol><li>从最顶端加上一个元素（push）</li><li>从最顶端删去一个元素（pop）</li></ol><p>一般来说，top指向<b>栈最顶端的元素的上面</b>。也就是说，如果现在栈为空，则<code>top == 0</code>；如果栈里面有一个元素，则<code>top == 1</code>。</p><p>这里给出一个经典的int栈，以及它的所有操作：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">10000</span>];<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br>    <span class="hljs-built_in">stack</span>[top] = num;<br>    top++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span><br>&#123;<br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>[top+<span class="hljs-number">1</span>];<br>&#125;<span class="hljs-comment">//如果top &lt; 0,就会有问题，所以pop之前最好判断一下</span><br><br><br></code></pre></td></tr></table></figure><p>由代码也可以看出，栈是一个不需要初始化的数据结构，因为所有能够访问的数据，必然是自己push进去的，是确定的。</p><p>这里再给出一个结构体的栈，通用性会更强一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; node;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">top</span>;</span><br><span class="hljs-type">int</span> count;<span class="hljs-comment">//这个是用来记录栈的元素个数的，可有可无。主要是用来判断栈为空的时候方便一些。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">p</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>    p-&gt;data = e;<br>    p-&gt;next = top;<br>    top = p;<br>    count++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">p</span> =</span> top;<br>    <span class="hljs-type">int</span> e = top-&gt;data;<br>    top = top-&gt;next;<br>    <span class="hljs-built_in">free</span>(p);<br>    count--;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果嫌结构体麻烦的话，也可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//这里以第四次作业第四题为例</span><br><span class="hljs-type">int</span> op[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> pos[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>][<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> next_op,<span class="hljs-type">int</span> next_pos,<span class="hljs-type">char</span> next_str[])</span><br>&#123;<br>    op[top] = next_op;<br>    pos[top] = next pos;<br>    <span class="hljs-built_in">strcpy</span>(str[top],next_str);<br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//在这道题中，我们用出栈表示撤销，因此，出栈不需要返回任何东西，因为用不上。</span><br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>栈的经典问题有以下几个</p><ol><li>回文的判定</li><li>判定括号是否匹配</li><li>排火车纸牌游戏</li></ol><h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列就是一个FIFO（first in, first out）的数据结构，即：加数据只能队尾加，取数据只能从队头取。</p><p>所以队列的操作也无非就两个：</p><ol><li>从队尾加数据</li><li>从队头取数据</li></ol><p>先来一个经典的队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-built_in">queue</span>[<span class="hljs-number">10000</span>];<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>, head = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//入队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br>    <span class="hljs-built_in">queue</span>[tail] = num;<br>    tail++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span><br>&#123;<br>    head++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>[head - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，top 和 tail 指向的位置到底是一个元素，还是一个空位，完全看个人喜好。甚至管哪边叫头、哪边叫尾在不同的材料也会有所不同。</p><p>而我的做法是：<code>tail</code>是加入元素的方向，<code>head</code>是取出元素的方向。<code>queue[tail]</code> 是队尾的第一个空位， <code>queue[top]</code> 是队头的第一个元素。</p><p>聪明的你可能发现了，队列中都不需要同时存在很多数据，只要使用时间足够长，总有一天tail就会越界，而queue的 0~head 那么多空位就被白白浪费了。</p><p>虽然在平时的作业中，其实只要将queue开得足够大就好），但是这里还是给出一个解决方法：循环队列。即tail用完了，就回到0 接着用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 10000 </span><br><br><span class="hljs-type">int</span> <span class="hljs-built_in">queue</span>[MAXSIZE];<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>, head = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//和上面相比，其实只是将 xxx++ 换成了 xxx=(xxx+1)%MAXSIZE</span><br><span class="hljs-comment">//入队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br>    <span class="hljs-built_in">queue</span>[tail] = num;<br>    tail=(tail + <span class="hljs-number">1</span>) % MAXSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">queue</span>[head];<br>    head = (head + <span class="hljs-number">1</span>) % MAXSIZE; <span class="hljs-comment">//这里与上面相比有一些变化，注意一下。</span><br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，它也是有可能满的（当 tail == top 时）</p><p>同理，也可以写一个链表构成的队列），这样的好处就是可以突破数组大小的限制，不过这个就太不常见了，循环队列就很够用了。如果真的需要用“结构体”作为队列的元素，用多个数组代替烦人的指针（和上面的栈同理）也很好。这里就偷个懒不写了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="C程序括号匹配检查"><a href="#C程序括号匹配检查" class="headerlink" title="C程序括号匹配检查"></a>C程序括号匹配检查</h2><p>这道题是经典的栈题，基本操作如下：</p><ol><li>当遇到左括号时：判断当前括号是否合法。若合法，则在栈顶放置这个左括号。</li><li>当遇到右括号时：判断它与当前栈顶的括号是否成对。若成对，则删去栈顶的左括号。</li></ol><p>这道题比较容易出bug，这里给出几个经典的样例以供测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">(&#123;&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*/</span><br>*/<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*/</span><span class="hljs-regexp">/*/</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;()&quot;</span>(<br></code></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-template-variable">&#123;&#123;)&#125;&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/**/</span><br></code></pre></td></tr></table></figure><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;&#123;()&#125;<br></code></pre></td></tr></table></figure><p>下面给出完整代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    FILE *in;<br>    <span class="hljs-type">int</span>  i, ansTop = <span class="hljs-number">0</span>, top = <span class="hljs-number">0</span>, len;<br>    <span class="hljs-type">int</span> msg = <span class="hljs-number">0</span>;<span class="hljs-comment">//message，如果发现出错，则将msg置1；如果正常到了文件尾而msg==0，则说明没有出错。</span><br>    <span class="hljs-type">int</span> inside = <span class="hljs-number">0</span>;<span class="hljs-comment">//由于题目特殊要求，inside表示：当前光标在n层的小括号内，其中n == inside</span><br>    <span class="hljs-type">char</span> line[<span class="hljs-number">210</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用来读文件的一行</span><br>    <span class="hljs-type">char</span> signStack[<span class="hljs-number">200</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用来放括号的栈</span><br>    <span class="hljs-type">int</span> lineStack[<span class="hljs-number">200</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//用来放括号的行数的栈</span><br>    <span class="hljs-type">char</span> errorSign = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录错误的符号</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来记录当前行数。</span><br>    <span class="hljs-type">char</span> ans[<span class="hljs-number">200</span>] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//ans 用来存最终的正确括号串</span><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">0</span>; <span class="hljs-comment">// key==0正常，key==1跨行注释,key==2跨行双引号,key==3跨行单引号</span><br>    <span class="hljs-keyword">if</span> ((in = fopen(<span class="hljs-string">&quot;example.c&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (fgets(line, <span class="hljs-number">201</span>, in) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            cnt++;<br>            len = <span class="hljs-built_in">strlen</span>(line);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0</span> &amp;&amp; (line[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || line[i] == <span class="hljs-string">&#x27;(&#x27;</span>))<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                    &#123;<br>                        inside++;<br>                    &#125;<br>                    signStack[top] = line[i];<br>                    lineStack[top] = cnt;<br>                    ans[ansTop] = line[i];<br>                    ansTop++;<br>                    top++;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; inside != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        top--;<br>                        <span class="hljs-keyword">while</span> (signStack[top] != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                            top--;<br>                        errorSign = <span class="hljs-string">&#x27;(&#x27;</span>;<br>                        cnt = lineStack[top];<br>                        msg = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0</span> &amp;&amp; line[i] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (line[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (line[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                    &#123;<br>                        key = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; line[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>                        key = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0</span> &amp;&amp; line[i] == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>)<br>                &#123;<br>                    key = <span class="hljs-number">3</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">3</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;\&#x27;&#x27;</span>)<br>                        key = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0</span> &amp;&amp; line[i] == <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>                &#123;<br>                    key = <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>                        key = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-number">0</span> &amp;&amp; (line[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> || line[i] == <span class="hljs-string">&#x27;)&#x27;</span>))<br>                &#123;<br>                    top--;<br><br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)<br>                        &#123;<br>                            errorSign = line[i];<br>                            msg = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (signStack[top] == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                        &#123;<br>                            ans[ansTop] = line[i];<br>                            ansTop++;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            errorSign = line[i];<br>                            msg = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>)<br>                        &#123;<br>                            errorSign = line[i];<br>                            msg = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (signStack[top] == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                        &#123;<br>                            ans[ansTop] = line[i];<br>                            ansTop++;<br>                            inside--;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            errorSign = line[i];<br>                            msg = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;without maching &#x27;%c&#x27; at line %d&quot;</span>, errorSign, cnt);<br>                fclose(in);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (top != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;without maching &#x27;%c&#x27; at line %d&quot;</span>, signStack[<span class="hljs-number">0</span>], lineStack[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, ans);<br>        &#125;<br>    &#125;<br>    fclose(in);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h2><p>这道题其实不用逆波兰也可以做（或者说，其他做法其实也是广义的逆波兰），但还是给大家介绍一下逆波兰的思路。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tap">逆波兰：（不需要括号的四则运算后缀表达法）<br>i. 9+（3-1）*3+10/2  ====&gt;   <span class="hljs-number"> 9 </span>3<span class="hljs-number"> 1 </span>-<span class="hljs-number"> 3 </span>* +<span class="hljs-number"> 10 </span>2  / +<br>ii. 将中缀表达式转化为后缀表达式<br>转入方法：<br>    1) + - 为一级，* / % 为更高的一级<br>                        2) 遇到数字：打印数字<br>                        3) 遇到与栈顶同级的符号：栈顶的符号出栈并打印，并将扫到的符号入栈<br>4) 遇到比栈顶高级的符号：高级符号入栈<br>           5) 遇到比栈顶低级的符号：从栈顶往下打印整个栈，打印完后，这个符号入栈<br>6) 遇到左括号：左括号进入栈<br>7) 右括号：从栈顶往下打印符号，直到左括号停止，并让左括号出栈。<br>                        8) 结尾：从栈顶往下打印所有符号<br>iii. 将后缀表达式进行运算得出结果<br>1) 从左往右扫描后缀表达式<br>2) 遇到数字：堆到栈里<br>3) 遇到符号：顶上的两个数字进行计算<br>iv. 表达式树：由后缀表达式转化（作为了解）<br>1) 遇到数字，数字入栈<br>2) 遇到符号，栈顶的两个弹出，作为该符号的左右子树，然后符号进栈<br>                3) 最终即为表达式树<br></code></pre></td></tr></table></figure><p>我们只做计算器，而不需要输出后缀表达式的话，就不需要像上面这段笔记这样，得出后缀表达式再重新扫描后缀表达式，我们只需将【出栈】，改为【顶上的两个数字按照符号进行计算】即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">1</span>) + - 为一级，* / % 为更高的一级<br><span class="hljs-number">2</span>) 遇到数字：数字进入数字栈<br><span class="hljs-number">3</span>) 符号栈为空：这个符号入栈<br><span class="hljs-number">3</span>) 遇到与符号栈栈顶同级的符号：栈顶的符号出栈，从数字栈栈顶取出两个数字，按照这个符号计算数字栈栈顶的两个数字，将结果入数字栈。最后将扫到的高级符号入栈<br><span class="hljs-number">4</span>) 遇到比符号栈栈顶高级的符号：高级符号入栈<br><span class="hljs-number">5</span>) 遇到比栈顶低级的符号：符号栈从栈顶逐一出栈，从数字栈栈顶取出两个数字，按照出栈的符号计算数字栈栈顶的两个数字，将结果入数字栈。最后将扫到的低级符号入栈<br><span class="hljs-number">6</span>) 遇到左括号：左括号进入栈<br><span class="hljs-number">7</span>) 右括号：符号栈从栈顶逐一出栈，从数字栈栈顶取出两个数字，按照出栈的符号计算数字栈栈顶的两个数字，将结果入数字栈。直到左括号停止，并让左括号出栈。<br><span class="hljs-number">8</span>) 结尾：从栈顶往下让所有符号出栈。<br></code></pre></td></tr></table></figure><h2 id="文本编辑操作模拟"><a href="#文本编辑操作模拟" class="headerlink" title="文本编辑操作模拟"></a>文本编辑操作模拟</h2><p>这道题的难点在于撤销操作，如果我们愣是将撤销处理成：复原上一个操作，比如上一个操作做了删除，那就撤销就是加回去；这道题就会变得很复杂。</p><p>最简单的解决方法是：</p><ol><li>遇到指令，则让指令入栈。</li><li>遇到撤回，则让栈顶的指令出栈，即删除最近的一个操作。</li><li>遇到结束，则从栈底开始，一个一个执行指令，直到栈顶。</li></ol><p>这里再贴一遍这个栈的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//这里以第四次作业第四题为例</span><br><span class="hljs-type">int</span> op[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> pos[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>][<span class="hljs-number">520</span>];<br><span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> next_op,<span class="hljs-type">int</span> next_pos,<span class="hljs-type">char</span> next_str[])</span><br>&#123;<br>    op[top] = next_op;<br>    pos[top] = next pos;<br>    <span class="hljs-built_in">strcpy</span>(str[top],next_str);<br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//在这道题中，我们用出栈表示撤销，因此，出栈不需要返回任何东西，因为用不上。</span><br>    top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="银行排队模拟"><a href="#银行排队模拟" class="headerlink" title="银行排队模拟"></a>银行排队模拟</h2><p>这道题坑害了一代又一代的北航学子……因为它的机制实在是太奇怪了。</p><p>这道题注意读题，这道题的难点就在于读题）。你只需要按照题目的意思，将文字翻译成代码就好，不要管这样是否符合逻辑，不要管这样是否符合管理要求，务必逐句逐句地翻译。</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2022/03/26/OO-unit1/"/>
    <url>/2022/03/26/OO-unit1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将按照作业的顺序依次展示作业中的思路，以及个人认为比较有价值的代码。考虑到阅读体验，本文将圈复杂度分析放在了文末。</p><h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><h2 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h2><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133035239-1502470451.png"></p><p>整个表达式的处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133652693-478656214.png"></p><h2 id="空白符的处理"><a href="#空白符的处理" class="headerlink" title="空白符的处理"></a>空白符的处理</h2><p>空白符在一开始直接删去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> string.replaceAll(<span class="hljs-string">&quot;[ \\t]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>这一方法将延续三次作业</p><h2 id="简化方式"><a href="#简化方式" class="headerlink" title="简化方式"></a>简化方式</h2><h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p>化简这一步的示意图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325141828163-1971151374.png"></p><p>在<code>expr.simplify()</code>这一步中，因子只能是x或常数，因此，在简化时，只需要递归地向上传一个<code>HashMap&lt;Biginteger, Biginteger&gt;</code>，在<code>term.simplify()</code>中，完成<code>HashMap&lt;Biginteger, Biginteger&gt;</code>之间相乘，在<code>expr.simplify()</code>中完成<code>HashMap&lt;Biginteger, Biginteger&gt;</code>的相加即可。其中，前面的Biginteger代表指数，后面的Biginteger代表系数。</p><h2 id="符号处理"><a href="#符号处理" class="headerlink" title="符号处理"></a>符号处理</h2><p>观察表达式的形式化表述：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">表达式 → 空白项 [加减 空白项] 项 空白项 <span class="hljs-string">| 表达式 加减 空白项 项 空白项</span><br>项 → [加减 空白项] 因子 <span class="hljs-string">| 项 空白项 * 空白项 因子</span><br></code></pre></td></tr></table></figure><p>可以发现，如果不考虑数量，所有的加减号理论上都可以认为是项（Term）前面的符号。因此，在符号处理上，在表达式处理流程的<code>parseExpr()</code>这一步中，符号将交由<code>Parser</code>中的<code>parseTerm()</code>方法开头处统一处理。</p><p>而带符号的整数中，发现Biginteger(string)的方法，可以处理string前的正负号，因此直接用这一函数处理。</p><p>这一处理方法将会延续整个第一单元。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>将<code>x**2</code>替换为<code>x*x</code>可以减少一个字符。处理方法为：在<code>printRes()</code>这一步中，对即将打印的<code>x**2</code>进行特判，并进行替换即可。</li><li><code>-x+1</code>这样负号在前的表达式，可换为<code>1-x</code>从而减小长度。处理方法为：遍历<code>HashMap&lt;Biginteger, Biginteger&gt;</code>的所有元素，找到系数为正数的项提前打印并删除，再将这个HashMap进行一般流程的打印。</li></ol><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133101155-117133541.png"></p><p>表达式的整个处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325135159332-2023732794.png"></p><p>本次作业中，将第一次作业的表达式层次：<code>Expr-Term-Factor</code>改为<code>Expr-Term-Pow-Factor</code>。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>笔者对自定义函数的处理方式为<strong>字符串替换</strong>。字符串需要解决如下的问题：</p><h3 id="字符串替换不当导致语义变化"><a href="#字符串替换不当导致语义变化" class="headerlink" title="字符串替换不当导致语义变化"></a>字符串替换不当导致语义变化</h3><p>笔者的解决方法是：能加括号的地方尽可能加括号。</p><p>由于采用层次化的方法解析表达式，因此再深的括号，这个程序架构都能够充分展开，因此，能加括号的地方尽可能加括号并不会带来错误。</p><h3 id="形参为x时，替换可能出bug"><a href="#形参为x时，替换可能出bug" class="headerlink" title="形参为x时，替换可能出bug"></a>形参为x时，替换可能出bug</h3><p>对于自定义函数，由于自定义函数中的参数x、y、z出现的顺序不固定，且形参复用了自变量<code>x</code>这一字母。于是，如果直接进行字符串的替换，会误将自变量<code>x</code>当作形参<code>x</code>进行替换而出错。</p><p>对此，笔者的方法是：在<code>parseFunct()</code>这一步，将自定义函数的参数<strong>依次</strong>换为p、q、l这三个在整个流程中未使用的字母，这样就不用担心字符串替换时出错了。而后续替换，也将每一个形参替换为传入的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String[] letter = &#123; <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;p&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>而参数的匹配，采用的是正则表达式匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (funct.getCnt()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*),(.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*),(.*),(.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Pattern.compile(pattern);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> tmp.matcher(ori);<br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; funct.getCnt(); i++) &#123;<br>                functString = functString.replaceAll(letter[i], <span class="hljs-string">&quot;(&quot;</span> + matcher.group(<span class="hljs-number">1</span> + i) + <span class="hljs-string">&quot;)&quot;</span>);<br>                <span class="hljs-comment">// not sure</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h2><p>求和函数的处理同样是<strong>利用正则表达式匹配，并替换字符串</strong>。唯独需要注意的是，sin函数中也有“i”字符，进行替换的时候要当心不要将其换为常数。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">termString</span> <span class="hljs-operator">=</span> exp.replaceAll(<span class="hljs-string">&quot;(?&lt;!s)i&quot;</span>, <span class="hljs-string">&quot;(&quot;</span> + i + <span class="hljs-string">&quot;)&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="计算顺序的问题"><a href="#计算顺序的问题" class="headerlink" title="计算顺序的问题"></a>计算顺序的问题</h3><p>由于设计展开括号的时候，</p><h2 id="简化方式-1"><a href="#简化方式-1" class="headerlink" title="简化方式"></a>简化方式</h2><p>本次简化分为两步：展开括号（expand），进行合并（simplify）。</p><h3 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h3><p>流程示意图如下：<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325150902692-2022730891.png"></p><p>由于因子不再是只有数字和x了，因此向上传递<code>HashMap</code>不再行得通。因此，采用向上传递<code>ArrayList&lt;Term&gt;</code>的方式进行括号的展开。</p><h3 id="simplify"><a href="#simplify" class="headerlink" title="simplify"></a>simplify</h3><p>对项，需要将<code>Pow</code>类底数<code>base</code>相同的因子合并，且指数相加。</p><p>对表达式，需要识别除系数外相同的项<code>term</code>，并将其系数<code>coe</code>相加。</p><p>此时，考虑采用重写<code>HashCode()</code>和<code>equals()</code>方法，并利用<code>HashSet&lt;&gt;</code>的元素不可重复性。</p><p>大致的流程为：</p><p>在项中：将<code>ArrayList&lt;Pow&gt;</code>的每个元素逐一放入<code>HashMap&lt;Factor, BigInteger&gt;</code>中，若<code>Factor</code>为数字，则乘入系数<code>coe</code>中；若出现相同的<code>Factor</code>，则指数改为两者指数之和。最后删去指数为0的对。</p><p>在表达式中：将<code>ArrayList&lt;Term&gt;</code>的每个元素逐一放入<code>HashMap&lt;HashSet&lt;Pow&gt;,BigInteger&gt;</code>中，其中value为系数<code>coe</code>。若出现相同的<code>HashSet&lt;Pow&gt;</code>，则系数改为两者系数之和。最后删去系数为0的对。</p><p>由于化简之前已经进行了括号的展开<code>expand</code>，故不会出现<code>x</code>和<code>(x)</code>无法被认为相等的情况。（因为此时根本不会出现<code>(x)</code>）。</p><h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="奇偶优化"><a href="#奇偶优化" class="headerlink" title="奇偶优化"></a>奇偶优化</h3><p>由于cos、sin函数具有奇偶性，因此，无脑将cos、sin中的符号提出，至少是不会增加结果的长度的。</p><p>实现方法为：在<code>simplify()</code>这一步中，判断一下三角函数内因子的符号，如果为负，则改为正，并向外传递一个信号，<code>Term</code>类接到这个信号后，系数*-1即可。</p><h3 id="三角函数原点的值"><a href="#三角函数原点的值" class="headerlink" title="三角函数原点的值"></a>三角函数原点的值</h3><p>将sin(0)换为0，cos(0)换为1可以缩短结果长度。方法为：在<code>simplify()</code>这一步时，对三角函数里面的内容进行判断。若为0，则将<code>Pow</code>的底数<code>base</code>替换为数字类<code>Number</code>，其值与原三角函数相同。</p><h2 id="答案输出"><a href="#答案输出" class="headerlink" title="答案输出"></a>答案输出</h2><p>第二次作业中，答案字符串的复杂度要远远高于第一次作业，如果和第一次作业一样，在main函数写<code>printRes()</code>方法，那么这一方法的长度必然会超标。因此，本次作业改为采用在各个层次各自递归下降地<code>toString()</code>方法，并进行拼合。</p><p>由于数据限制，sin、cos中的<code>Term</code>在输出答案时，<code>x**2</code>不能被替换为<code>x*x</code>，故为sin、cos中的<code>Term</code>定制了一个转为字符串的方法<code>display()</code>，以满足题目要求。</p><h2 id="出现的bug"><a href="#出现的bug" class="headerlink" title="出现的bug"></a>出现的bug</h2><ol><li>由于之前一直采用<code>Biginteger(string)</code>的方式处理常数，可省去特判数字前的符号这一步骤。因此疏忽了数字前面可能会出现”+”。故并没有在匹配求和函数上下限时考虑数字前的“+”，导致正则表达式匹配求和函数时匹配失败。解决方法为：修正正则表达式，使其可以匹配”+”。</li><li>在奇偶优化时，未考虑三角函数的指数为偶数时，Term不应该*-1，导致出bug。解决方法为：将“如果为负，则改为正，并向外传递一个信号”改为“如果为负，则改为正，若三角函数指数为奇数，则向外传递一个信号”。</li><li>未进行深拷贝，导致项与项相乘时出错。</li></ol><h1 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h1><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133113128-1744181138.png"></p><p>表达式的整个处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325135159332-2023732794.png"></p><h2 id="三角函数的处理"><a href="#三角函数的处理" class="headerlink" title="三角函数的处理"></a>三角函数的处理</h2><p>由于三角函数中的因子限制放宽，因此在三角函数的化简过程有较大变化。三角函数sin、cos中的内容由常数或幂函数变为了一般的因子。笔者选择了<strong>直接按照表达式</strong>处理。</p><p>为了能充分复用第二次作业的代码，本次作业虽然将三角函数内的因子按表达式处理，但在expand这一步提前对三角函数内的表达式进行了<code>expr.simplify()</code>，并进行判断：若<code>Expr</code>只有唯一的项，且项的结果相当于常数或幂函数（即不需要加括号），则将表达式中唯一的项复制到<code>Sin</code>、<code>Cos</code>类里面的<code>Term</code>类属性中，并在<code>toString</code>的步骤中，按第二次作业的方法处理。反之，保留这个<code>Expr</code>类变量，在<code>toString</code>的步骤中，按表达式处理。</p><p>这里展示<code>toString()</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (term.getFinalPows().isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + term.display() + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (term.getPows().get(<span class="hljs-number">0</span>).getBase() <span class="hljs-keyword">instanceof</span> X<br>                &amp;&amp; term.getPows().get(<span class="hljs-number">0</span>).getExp().equals(BigInteger.valueOf(<span class="hljs-number">2</span>))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + <span class="hljs-string">&quot;x**2&quot;</span> + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + term.display() + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos((&quot;</span> + expr.toString() + <span class="hljs-string">&quot;))&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简化方式-2"><a href="#简化方式-2" class="headerlink" title="简化方式"></a>简化方式</h2><p>简化分为两步：展开括号（expand），进行合并（simplify）。</p><h3 id="expand-1"><a href="#expand-1" class="headerlink" title="expand"></a>expand</h3><p>示意图如下：<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325154222905-933010666.png"></p><p>大部分与第二次作业一致，除了三角函数类里增加了<code>Expr</code>类指令，并在<code>expand</code>的步骤中提前进行了<code>simplify</code>这一步。</p><h3 id="simplify-1"><a href="#simplify-1" class="headerlink" title="simplify"></a>simplify</h3><p>同作业二。</p><h2 id="性能优化-2"><a href="#性能优化-2" class="headerlink" title="性能优化"></a>性能优化</h2><p>本次作业未做额外的优化，优化方式同作业二。</p><h2 id="求和函数的参数替换"><a href="#求和函数的参数替换" class="headerlink" title="求和函数的参数替换"></a>求和函数的参数替换</h2><p>由于此时数据限制放宽，之前使用正则表达式提取参数将无法应对如<code>f(sum(i,1,2,(x)**2),((((x)))))</code>这样刁钻的数据。此时，考虑通过括号堆栈的方式，找到每一个逗号间隔内的内容。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">groupBegin[<span class="hljs-number">0</span>] = start + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">Funct</span> <span class="hljs-variable">funct</span> <span class="hljs-operator">=</span> functs.get(type);<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> lexer.getchar(end);<br>            <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>                num++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>                num--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;,&quot;</span>) &amp;&amp; num == <span class="hljs-number">1</span>) &#123;<br>                groupEnd[k] = end;<br>                k++;<br>                groupBegin[k] = end + <span class="hljs-number">1</span>;<br>            &#125;<br>            end++;<br>        &#125;<br>        groupEnd[k] = end - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="出现的bug-1"><a href="#出现的bug-1" class="headerlink" title="出现的bug"></a>出现的bug</h2><ol><li>版本迭代的时候没有注意到求和函数<code>sum</code>的求和上限与下限并没有明确的大小限制，因此在写的时候用<code>int</code>型的变量去装上下限了。爆栈的数据在第二、三次作业的中、强测中均未出现，因此并没有修改这一bug，而在互测环节被hack了。</li></ol><h1 id="圈复杂度分析"><a href="#圈复杂度分析" class="headerlink" title="圈复杂度分析"></a>圈复杂度分析</h1><h2 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135514037-2121458312.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135535589-1046267560.png"></p><h2 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135706474-670960018.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135718167-653735896.png"></p><p>由于Cal类中的方法，只在Term类中被使用。因此，如果将Cal中的方法直接写在Term里面，就可以少一个类，可以降低圈复杂度。</p><h2 id="第三次作业-1"><a href="#第三次作业-1" class="headerlink" title="第三次作业"></a>第三次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135725010-480457731.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135732991-399532382.png"></p><p>equals函数的圈复杂度这么高，好像也是没有办法。</p><p>这个阶段的作业由于不敢将原来的方法改写，想要实现新的功能时，就会重写一个方法，增加一些不必要的属性。可能这就是屎山的诞生吧。</p><h1 id="hack思路"><a href="#hack思路" class="headerlink" title="hack思路"></a>hack思路</h1><ol><li>常数： 考虑前导零和正负号的处理是否正确</li><li>幂函数：考虑零次方的结果是否恒为1，考虑项的合并是否正确。考虑偶次幂消去负号的这一步是否正确。</li><li>求和函数：考虑求和上下限是否支持正负，是否支持上限小于上限。考虑正负号的代入是否正确。</li><li>三角函数：考虑三角优化是否正确，考虑正负号的优化是否正确，考虑多层三角函数嵌套是否支持。</li><li>自定义函数：考虑参数的替换是否正确，考虑形参的顺序是否会干扰代入。</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>第一周的OO大主题为表达式的解析，整个作业的走向基本是可以预见到的。但是在实际书写的过程中，还是无法在一开始就想好以后的通用度问题，数据的覆盖面上，也比较依赖评测机。比如第二次作业相第三次作业迭代的时候，原以为第二次作业做的一些超前的工作，可以直接应付第三次作业，但是在开放中测后还是发现了很多问题，重写了不少代码。这一点可能还是个人能力不足。</p><p>以及，个人也曾立志要好好写一个数据生成程序和自动评测程序，但最后还是没写，白嫖了讨论区……</p><p>总体上还是有收获的吧，也有一些遗憾，希望以后能写得更好。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 第三次上机</title>
    <link href="/2022/03/24/ds-3/"/>
    <url>/2022/03/24/ds-3/</url>
    
    <content type="html"><![CDATA[<h1 id="连续线段"><a href="#连续线段" class="headerlink" title="连续线段"></a>连续线段</h1><p>对于每一个连续线段，其有用的信息只有：左右端点坐标、连续线段中的端点数。</p><p>因此可以考虑做一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> lx,ly,rx,ry,length;<br>    <span class="hljs-type">int</span> key; <span class="hljs-comment">//key的作用下面会说</span><br>&#125;line[<span class="hljs-number">105</span>];<br></code></pre></td></tr></table></figure><p>每输入一个新线段(x1,y1) (x2,y2)，都与现存的每个line的左右端点相比较，如果有重合的，则延长；如果没有，就开一条新的line存放这个线段。</p><p>这道题还要考虑一个线段连起两个line的情况！我的方法是这样的：在line结构体当中加一个变量key，当key==0时这个line有效。如果发现新建的线段连起了两个line，就把左边的那个line的右端点改为右边line的右端点，然后右边的那个line置key=1，即右边的line无效。</p><p>当然，采用“有效标志”去代表这个line是否被删除的方法也不怎么高效，也就是说，要表示“删去一个line”有更好的方法。比如，也可以简单地魔改右边的那个line，让它不可能再被延长，并让它的长度归零，从而达到删去右边那个line的效果。</p><h1 id="猴子选大王"><a href="#猴子选大王" class="headerlink" title="猴子选大王"></a>猴子选大王</h1><p>是一个经典的约瑟夫环问题。这个网上讲解很多，我就不重复造轮子了。</p><p>推荐教程：<a href="https://blog.csdn.net/qie_wei/article/details/87915174">https://blog.csdn.net/qie_wei/article/details/87915174</a></p><p>贴一下码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, m, n, q, a = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        a = (a + m) % i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (a + q - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面用的是公式法，当然用链表也是完全可以解题的。鉴于大家刚学链表，还是比较推荐大家用链表写。</p><h1 id="多项式相乘"><a href="#多项式相乘" class="headerlink" title="多项式相乘"></a>多项式相乘</h1><p>我们要开始接触链表啦！<br>一个经典的链表长这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//一些结点内的数据：</span><br>    <span class="hljs-type">int</span> c;<span class="hljs-comment">//c即系数coe</span><br>    <span class="hljs-type">int</span> e;<span class="hljs-comment">//e即指数exp</span><br>    <span class="hljs-comment">//连向下一个结点的指针：</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;*head;<span class="hljs-comment">//经常会有一个全局的链表头结点指针</span><br></code></pre></td></tr></table></figure><p>关于这个head，市面上有两种风格。</p><p>一个是：head是第一个有数据的结点；</p><p>另一个是：head-&gt;next 指向第一个有数据的结点。</p><p>选用哪一种全看个人习惯，本人采用第一种。</p><p>对于链表的经典操作有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *head)</span> <span class="hljs-comment">//反转链表</span><br>&#123;<br>    p = head-&gt;next;<br>    q = <span class="hljs-literal">NULL</span>;<br>    r = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        q = p;<br>        p = p-&gt;next;<br>        q-&gt;next = r;<br>        r = q;<br>    &#125;<br>    head-&gt;next = p;<br>    p-&gt;next = q;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//链接之前需要一个全局变量头指针。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">head</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e)</span> <span class="hljs-comment">//连接下一个结点，一开始扫入用</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">q</span>;</span><br>    q = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    q-&gt;c = c;<br>    q-&gt;e = e;<br>    q-&gt;next = head-&gt;next;<br>    head-&gt;next = q;<br>    head = q;<br>    <span class="hljs-comment">//仔细理解一下这个链接的过程，并想想为什么这个函数结束后，q被杀掉了也没关系？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e)</span> <span class="hljs-comment">//插入一个结点</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>, *<span class="hljs-title">r</span>;</span><br>    q = head;<br>    <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;e &gt; e) <span class="hljs-comment">//这里其实可以根据题目的需要，换成其他条件</span><br>    &#123;<br>        p = q;<br>        q = q-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//到了链表尾，在尾后加结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = <span class="hljs-literal">NULL</span>;<br>        q-&gt;next = r;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;e == e) <span class="hljs-comment">//满足一定条件，改变原有结点而不插入新结点</span><br>        q-&gt;c += c;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;e &lt; e &amp;&amp; q != head)<span class="hljs-comment">//在链表中间插结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = q;<br>        p-&gt;next = r;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q==head)<span class="hljs-comment">//在头前面插结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = q;<br>        head = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，我们应该就可以把输入的两个表达式做成链表存起来了。</p><p>具体实现已经被上面这些写得差不多啦，这里写一下实现的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//扫入第一个表达式，形成第一条链表</span><br>    <span class="hljs-comment">//扫入第二个表达式，形成第二条链表</span><br>    <span class="hljs-comment">//新建一个存答案的空链表</span><br>    <span class="hljs-keyword">for</span>()<span class="hljs-comment">//对第一个链表的每个项</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>()<span class="hljs-comment">//乘以第二个链表的每个项</span><br>        &#123;<br>            <span class="hljs-comment">//两项相乘得到新的项</span><br>            <span class="hljs-comment">//把新的项插入存答案的链表中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//打印答案链表</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h1><p>和上一题差不多，但是链表的结尾不再是NULL，而是指向head。</p><p>链表需要一个新功能：删除某个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设初始的链接状态下：</span><br><span class="hljs-comment">p ==&gt; q ==&gt; r;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>    p-&gt;next = r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure><h1 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h1><p>和前面的题性质差不多，我就直接贴我当年的代码了，只可参考，不可复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> word[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; * head, *p, *q, *r;<br><span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span><br>&#123;<br>    q = head;<br>    <span class="hljs-keyword">while</span> (q-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        q = q-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d\n&quot;</span>, q-&gt;word, q-&gt;time);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *p)</span><br>&#123;<br><br>    q = head;<br>    r = q;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            p-&gt;next = <span class="hljs-literal">NULL</span>;<br>            r-&gt;next = p;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;word, p-&gt;word) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            r = q;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;word, p-&gt;word) &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                r-&gt;next = p;<br>                p-&gt;next = q;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q-&gt;time++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">500</span>];<br>    <span class="hljs-type">int</span> i, j, len;<br>    head = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;word[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    FILE *in;<br>    <span class="hljs-keyword">if</span> ((in = fopen(<span class="hljs-string">&quot;article.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (fgets(s, <span class="hljs-number">200</span>, in) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            len = <span class="hljs-built_in">strlen</span>(s);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || <span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>                &#123;<br>                    p = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>                    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>                    p-&gt;time = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; <span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || <span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>;)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br><br>                        &#123;<br>                            s[i] = s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>                        &#125;<br>                        p-&gt;word[j] = s[i];<br>                        i++;<br>                        j++;<br>                    &#125;<br>                    p-&gt;word[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                    insert(p);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        print();<br>    &#125;<br>    fclose(in);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>代码查重工作近期要开始啦，助教会亲自审判查重率高的同学，所以注意不要copy！！！</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word文档转txt小程序</title>
    <link href="/2022/03/13/doc2txt/"/>
    <url>/2022/03/13/doc2txt/</url>
    
    <content type="html"><![CDATA[<p>麻了，网上的word文档转txt的代码没有一个能跑的。要不然就是通用性极差，得专门按序号命名才行。</p><p>这里缝合了两个doc2txt的python代码，以期中文互联网上多一份能跑的代码。</p><p>跑之前要先安装win32com，在cmd下输入：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">python -m pip install pypiwin32<br></code></pre></td></tr></table></figure><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32com.client<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_word_to_txt</span>(<span class="hljs-params">word_path, save_path</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;读取&#x27;</span>+word_path)<br>    word = win32com.client.Dispatch(<span class="hljs-string">&#x27;Word.Application&#x27;</span>)  <span class="hljs-comment"># 调用word应用</span><br>    doc = word.Documents.Open(word_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存中。。。&#x27;</span>)<br>    doc.SaveAs(save_path, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 保存格式为txt</span><br>    doc.Close()<br>    word.Quit()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_doc</span>():<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\a1271\Desktop\\脱敏-ID, PHONE, NAME，文件名\\脱敏-ID, PHONE, NAME，文件名\\*.doc&#x27;</span>):<span class="hljs-comment"># 要读取的.doc文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\a1271\Desktop\\脱敏-ID, PHONE, NAME，文件名\\脱敏-ID, PHONE, NAME，文件名\\*.docx&#x27;</span>):<span class="hljs-comment"># 要读取的.docx文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br><br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> next_doc():<br>    name, ext = os.path.splitext(doc)<br>    readPath = doc <br>    savePath =name+<span class="hljs-string">&quot;.txt&quot;</span>  <span class="hljs-comment"># 保存的绝对路径，这里默认转到相同路径</span><br>    change_word_to_txt(readPath, savePath)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存成功！&#x27;</span>)<br></code></pre></td></tr></table></figure><p>只需要新建一个.py文件，把代码复制进去，然后更改里面的那两行绝对路径为word文件所在文件夹，运行，就可以在word文件的同目录生成同名的.txt文件了。.doc / .docx 文件都可以实现转换。</p><p>估计也就人工制作有标记数据的可怜人能用的上了吧(允悲)</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 第二次上机</title>
    <link href="/2022/03/10/ds-2/"/>
    <url>/2022/03/10/ds-2/</url>
    
    <content type="html"><![CDATA[<p>本周上机的难点主要在结构体和排序上面。</p><h1 id="结构体表示方法"><a href="#结构体表示方法" class="headerlink" title="结构体表示方法"></a>结构体表示方法</h1><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>一般来说，结构体是这么定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> </span><br><span class="hljs-class">//<span class="hljs-keyword">struct</span>：表示你即将定义一个与<span class="hljs-title">int</span>、<span class="hljs-title">char</span>、<span class="hljs-title">long</span> <span class="hljs-title">long</span> 相平行的一个【数据类型】</span><br><span class="hljs-class">//<span class="hljs-title">Node</span>:</span> 表示你定义的这个【数据类型】，也就是结构体，叫做Node。首字母大写只是程序员的习惯，不是必须的。<br>&#123;<br>    <span class="hljs-comment">//将以下的“成员” 打包在一起，作为这个数据类型</span><br>    <span class="hljs-comment">//这第四题的实例</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<span class="hljs-comment">//这个order的作用在下面的“让快排变稳定”会用到</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n</span>;</span><br><span class="hljs-comment">//声明结构体的方法：【数据类型】+【结构体的名字】，这个可以类比&quot; int num; &quot; 来理解</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-comment">//声明一个结构体指针，这里可以类比&quot; int *a; &quot; 来理解</span><br><span class="hljs-comment">//指针经常习惯性地叫它p，是pointer的简称</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>[100];</span><br></code></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<br>&#125; n, *p, *ptr[<span class="hljs-number">100</span>];<span class="hljs-comment">//注意，声明部分出现在分号前面</span><br></code></pre></td></tr></table></figure><p>结构体与 int，long long，等数据类型相同，它们声明完就可以直接开始赋值。而结构体【指针】的赋值等等操作之前，必须要先为它分配一个空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br></code></pre></td></tr></table></figure><p>可能有同学第一次接触 malloc，也不明白什么叫“分配一个空间”。这里简单地讲解一下。</p><h4 id="malloc-与结构体指针"><a href="#malloc-与结构体指针" class="headerlink" title="malloc 与结构体指针"></a>malloc 与结构体指针</h4><p>先用int作一个类比讲解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> b;<br><span class="hljs-comment">//这条代码执行完之后，就分配好了一个int的空间</span><br><span class="hljs-type">int</span> *a;<br><span class="hljs-comment">//这条代码执行完之后，分配好了一个指针的空间</span><br>a = &amp;b;<br><span class="hljs-comment">//这条代码执行完之后，为a的内容写上b的地址，相当于让a指向b</span><br></code></pre></td></tr></table></figure><p>结构体同理。理论上也可以这么用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n</span>[100];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>[100];</span><br><br>ptr[<span class="hljs-number">0</span>] = &amp;n[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>但是这样未免太脑瘫了，我干嘛不直接用n，而去用ptr呢？</p><p>这是因为，在后续的章节，我们逐渐接触到树、链表等等数据结构之后，我们将实现用一个指针，去完成对一堆结构体的构建、查找、排序、删除。首先，我们就要学着用结构体指针 去操作一个【无名结构体】。</p><p>我们再回到刚才的代码。同样，我们用int进行类比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *a;<br><span class="hljs-comment">//这条代码执行完之后，分配好了一个指针的空间</span><br>a = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-comment">//这条代码执行完之后，为a的内容写上b的地址，相当于让a指向一个int大小的空间【的开头】。</span><br></code></pre></td></tr></table></figure><p>这样，我们就让int指针，指向了一个无名的int空间。</p><p>于是，为结构体指针“分配空间”，指的就是“为它指向的目的地分配一个结构体那么大的空间”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br></code></pre></td></tr></table></figure><p>而结构体是这么访问的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>;</span><br>ptr = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br><span class="hljs-comment">//结构体</span><br>n.order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = n.order;<span class="hljs-comment">//读取</span><br><br><span class="hljs-comment">//结构体指针</span><br>p-&gt;order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = p-&gt;order;<span class="hljs-comment">//读取</span><br></code></pre></td></tr></table></figure><p>为结构体指针分配空间至关重要，要是不做这一步的话，结构体指针的目的地就没有一个结构体那么大的空间，这个指针就相当于野指针。对它的访问和写入都是没有意义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>;</span><br>ptr-&gt;order = <span class="hljs-number">3</span>;<span class="hljs-comment">//这行代码会报错。</span><br></code></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>要是头铁也可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//这是第五题的实例</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">505</span>][<span class="hljs-number">200</span>];<br><span class="hljs-type">char</span> author[<span class="hljs-number">505</span>][<span class="hljs-number">23</span>];<br><span class="hljs-type">char</span> loc[<span class="hljs-number">505</span>][<span class="hljs-number">33</span>];<br><span class="hljs-type">char</span> date[<span class="hljs-number">505</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//前四行看作是结构体内部的成员</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">505</span>];<span class="hljs-comment">//这一行看作是结构体指针</span><br></code></pre></td></tr></table></figure><p>book[505] 相当于505个结构体指针，那要怎么访问呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如我们要写入book[0]的信息</span><br>book[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//相当于第一位的书是“0号书”</span><br>name[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;harryPotter&quot;</span>;<br>author[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;JK&quot;</span>;<br>loc[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;London&quot;</span>;<br>date[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;2000&quot;</span>;<br><span class="hljs-comment">//访问同理</span><br></code></pre></td></tr></table></figure><p>book[0] = 0; 看似很多余。但是由于后续涉及到排序，以后book[0]，也就是排在最前面的书，就未必是0号书了。比如如果一顿排序，排在最前面的书是7号书，则此时book[0]==7。假设这本0号书在排序过后，排在了第三位，也就是book[2]==0; 则有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, name[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;harryPotter&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, author[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;JK&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, loc[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;London&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, date[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;2000&quot;</span><br></code></pre></td></tr></table></figure><p>这么表示感觉会抽象很多，代码的可读性也更差，但有个好处，就是访问的速度比较快。曾几何时，数据结构课的大作业是需要竞速的，此时，要想卷性能分，就会采用这种方式写结构体。</p><h1 id="结构体的排序"><a href="#结构体的排序" class="headerlink" title="结构体的排序"></a>结构体的排序</h1><h3 id="如何交换"><a href="#如何交换" class="headerlink" title="如何交换"></a>如何交换</h3><p>回忆int 类型的数据如何交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>而结构体理论上也可以通过这种方式进行直接赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Node a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>但是这样交换太不优雅了，那么庞大的数据，说复制就复制，说覆盖就覆盖。所以，一般采用指针进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>&#125;<br>Node *a, *b, *tmp;<br>a = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>b = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br><span class="hljs-comment">//……</span><br><br><span class="hljs-keyword">if</span>( a-&gt;num &lt; b-&gt;num )&#123;<span class="hljs-comment">//如果要交换的话</span><br>    tmp = b;<br>    b = a;<br>    a = b;<br>&#125;<br></code></pre></td></tr></table></figure><p>知道了怎么交换，就可以自己写冒泡排序啦。</p><h3 id="如何让快排变稳定"><a href="#如何让快排变稳定" class="headerlink" title="如何让快排变稳定"></a>如何让快排变稳定</h3><p>众所周知，快排是一个不稳定的排序，也就是说，当被比较的两个元素被认为大小相等时，它们两个在被排序之后的顺序是不确定的。</p><p>而本次作业，涉及到了排序稳定性的问题。当然，此时直接自己写一个冒泡排序完全可以，但是<del>qsort实在是太好用了</del>。这里简单讲讲如何实现稳定的快排。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">//以下代码是第四题实例的排序，忘了这些变量名是什么含义的话，请往上翻一翻</span><br>    qsort(ptr,n,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node *),cmp); <span class="hljs-comment">//n表示有几本书</span><br><br><span class="hljs-comment">//可以看看这个地方是如何对指针进行排序的</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *b)</span><span class="hljs-comment">//一个\*！！</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">i</span> =</span> *(<span class="hljs-keyword">struct</span> Node **)a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">j</span> =</span> *(<span class="hljs-keyword">struct</span> Node **)b;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name);<br>    <span class="hljs-keyword">if</span> (i-&gt;order &gt; j-&gt;order)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//这里用升序的写法，假装它是稳定的</span><br>    <span class="hljs-keyword">if</span> (i-&gt;order &lt; j-&gt;order)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>order 即为顺序，首先，在输入每一个人的时候，为每一个结构体的order赋初值，也就是1、2、3、4、5……第i个录进来的，就为它的order赋值为i。</p><p>然后让order成为cmp（比较函数）中【权重较低】的那个。</p><p>这样，order较低（也就是较早被录入）的人，就会被排在前面，从而实现了稳定的qsort。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 第一次上机</title>
    <link href="/2022/03/03/ds-1/"/>
    <url>/2022/03/03/ds-1/</url>
    
    <content type="html"><![CDATA[<p>题目总体很程设，这里主要给出三道题的参考代码</p><h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h1><p>可以用层次化的思维去理解表达式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 +或- 项 +或- 项项 = 因子 *或/ 因子 *或/ 因子</code></pre></div><p>这样一来就可以考虑写个递归完成它。</p></space><p>当然还有一种更优雅的处理加减的方式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 + 项 + 项项 = +/- (因子 */ 因子 */ 因子)</code></pre></div><p>这样一来，在项结算的时候乘以1或-1，于是表达式只需要无脑加就可以了，思维量减小不少。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span><br>&#123;<br>    <span class="hljs-comment">//……</span><br>        <span class="hljs-comment">//如果发现是减</span><br>        <span class="hljs-keyword">return</span> num * sign + cal(<span class="hljs-number">-1</span>);<span class="hljs-comment">//传入的参数就是sign</span><br>    <span class="hljs-comment">//……</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>再优雅一点，可以把重复使用功能写成一个函数，比如下文的getNum()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span> <span class="hljs-comment">//用sign来标记这一项是正是负，也就是它的前面是加是减</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp;<br><span class="hljs-type">int</span> flag; <span class="hljs-comment">//用来标记计算方式， 1 为 * , 2 为 /</span><br><br><span class="hljs-comment">//项的开头必然是数字，所以先赋值一个数字</span><br>num = getNum();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//收尾部分：如果这一项结束了，进入收尾代码</span><br><br>        <span class="hljs-comment">//收尾代码</span><br><br><span class="hljs-comment">//循环部分：各种乘除</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[step]))<br>&#123;<br>tmp = getNum();<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>num *= tmp;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>num /= tmp;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br>            step++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">2</span>;<br>            step++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题有一点难想的部分可能就是：如何在获得因子之后，知道它与前面数字的计算是乘是除。代码中已经给了一个还不错的方法。</p><p>每进一步，都及时地进行计算，这样拿在手上的数字就不会太多，也会比较好想。</p><p>要是还想再优雅一点，由于项对每个因子的计算都是乘法/除法，而1*任何数字还是其本身，所以可以不为项的第一个因子写getNum()，而直接进入“标准化作业”。想想看怎么写吧。</p><p>掌握对表达式的层次化理解，非常有助于自己编程思维的形成。以后必然会出现涉及括号的表达式计算，有兴趣的同学也可以想想要怎么实现。</p><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><p>就是模拟竖式减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-type">void</span> <span class="hljs-title function_">jian</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> l1 = <span class="hljs-built_in">strlen</span>(s);    <span class="hljs-comment">//字符串长度 </span><br>    <span class="hljs-type">int</span> l2 = <span class="hljs-built_in">strlen</span>(ss);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;         <span class="hljs-comment">//一个记录正负的变量（后面就知道啦） </span><br><br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));       <br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));  <br><br>    <span class="hljs-keyword">if</span> ( l1 &lt; l2 || (<span class="hljs-built_in">strcmp</span>(s,ss) &lt; <span class="hljs-number">0</span> &amp;&amp; l1 == l2) )    <span class="hljs-comment">//这个比较重要是来判断前后两数的大小的  </span><br>    &#123;                                           <span class="hljs-comment">//不然一个小的数减一个大的数是大于零的就尴尬了</span><br>        flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里是把正负记录下来  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)    <span class="hljs-comment">//倒过来输入 </span><br>            a[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;      <span class="hljs-comment">//将字符串里的字符转换为数字 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)   <span class="hljs-comment">//同理，倒过来输入 </span><br>            a[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 &gt; l2) <br>        len = l1;             <span class="hljs-comment">//len赋值为其中大的数 </span><br>    <span class="hljs-keyword">else</span> <br>        len = l2; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++)<br>    &#123;<br>        a[i] = a[i] - b[i];     <span class="hljs-comment">//运算 </span><br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//如果减得多了 </span><br>        &#123;<br>            a[i+<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span>;         <span class="hljs-comment">//向前要一位 </span><br>            a[i]+=<span class="hljs-number">10</span>;          <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (a[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; len&gt;<span class="hljs-number">1</span>) len--;   <span class="hljs-comment">//while去零法，了解一下（名字现编的，别搜百度了） 这个&amp;&amp;len&gt;1 很重要，防止结果为0 不输出。</span><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);     <span class="hljs-comment">//如果结果是负的，先输出一个负号 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span> ;i &gt;= <span class="hljs-number">0</span> ;i--)   <span class="hljs-comment">//再输出结果 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <span class="hljs-comment">//换行 </span><br>&#125;                           <span class="hljs-comment">//高精度减法你懂了吗？ </span><br></code></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>把求全排列想象成：手上有 1~n n张数字卡片，依次放入编号为1~n的盒子里面。用book[]数组记录某个卡片是否被使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">fullArray(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> n)<br>&#123;<br><br>    <span class="hljs-comment">//收尾情况的代码：盒子放满后，进入收尾代码</span><br>    <span class="hljs-comment">//收尾代码：逐一打印数字卡片</span><br><br>    <span class="hljs-comment">//递归部分的代码：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//每一步都从最小的开始尝试放数字</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (book[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">//如果还没有被用</span><br>        &#123;<br>            a[step] = i;      <span class="hljs-comment">//用一个数组装卡片，放下数字卡片</span><br>            book[i] = <span class="hljs-number">1</span>;      <span class="hljs-comment">//表明放下的数字卡片被占用</span><br>            fullArray(step + <span class="hljs-number">1</span>, n); <span class="hljs-comment">//开始下一步</span><br>            book[i] = <span class="hljs-number">0</span>;      <span class="hljs-comment">//取回数字卡片</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于官方数字量不大，非要打表也不是不行（误）。</p><p>看到这里，就关掉网页自己写一遍吧。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. 开始</title>
    <link href="/2022/02/26/beginning/"/>
    <url>/2022/02/26/beginning/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>数据结构系列博客 旨在帮助北航2022信息类数据结构课的同学们，提供（与CSDN相比）质量较好的代码。博客内容包含数据结构中涉及的算法、数据结构模板，以及部分知识的讲解，并提供<del>充分的</del>注释以供同学们参考学习。  </p><p>代码主要来自个人作业以及个人笔记，且本人水平有限，代码风格欠佳，故不保证正确性，如发现有问题，或有更好的补充，欢迎在评论区指正，本人必及时修改。</p><p>本博客与课程进度（大概）同步更新。</p><h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><ol><li>数据结构课的作业、考试均在自己的电脑上完成，所以非常建议大家转用vs code，界面好看功能多，调试更友好。</li><li> vs code 下，ctrl＋alt＋F（dev C++ 下，ctrl＋shift<br>＋A）可以格式化代码，让代码更好读，也有助于助教解答。</li><li>judge平台可以进行在线答疑，会有助教轮班解答。</li><li>推荐书籍：《啊哈算法》、《大话数据结构》，两本书基本覆盖数据结构课程内容。</li><li>数据结构的题目都很经典，一般在网上就可以找到完全匹配的算法。所以实在不会可以试着百度一下题干。</li></ol><h1 id="特别警告"><a href="#特别警告" class="headerlink" title="特别警告"></a>特别警告</h1><p>数据结构课程组<strong>十分重视抄袭问题！系统会对提交的代码进行查重！</strong>故<strong>万万不可复制博客中的代码</strong>，也尽量不要对着博客写代码，防止被 认定/误认定 为抄袭。博客中的代码仅供参考，作业中的代码烦请自行书写。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
