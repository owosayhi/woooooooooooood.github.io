<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>word文档转txt小程序</title>
    <link href="/2022/03/13/doc2txt/"/>
    <url>/2022/03/13/doc2txt/</url>
    
    <content type="html"><![CDATA[<p>麻了，网上的word文档转txt的代码没有一个能跑的。要不然就是通用性极差，得专门按序号命名才行。</p><p>这里缝合了两个doc2txt的python代码，以期中文互联网上多一份能跑的代码。</p><p>跑之前要先安装win32com，在cmd下输入：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">python -m pip install pypiwin32<br></code></pre></td></tr></table></figure><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32com.client<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_word_to_txt</span>(<span class="hljs-params">word_path, save_path</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;读取&#x27;</span>+word_path)<br>    word = win32com.client.Dispatch(<span class="hljs-string">&#x27;Word.Application&#x27;</span>)  <span class="hljs-comment"># 调用word应用</span><br>    doc = word.Documents.Open(word_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存中。。。&#x27;</span>)<br>    doc.SaveAs(save_path, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 保存格式为txt</span><br>    doc.Close()<br>    word.Quit()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_doc</span>():<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\111\\Desktop\\fengru\\trans\\*.doc&#x27;</span>):<span class="hljs-comment"># 要读取的.doc文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\111\\Desktop\\fengru\\trans\\*.docx&#x27;</span>):<span class="hljs-comment"># 要读取的.docx文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br><br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> next_doc():<br>    name, ext = os.path.splitext(doc)<br>    readPath = doc <br>    savePath =name+<span class="hljs-string">&quot;.txt&quot;</span>  <span class="hljs-comment"># 保存的绝对路径，这里默认转到相同路径</span><br>    change_word_to_txt(readPath, savePath)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存成功！&#x27;</span>)<br></code></pre></td></tr></table></figure><p>只需要新建一个.py文件，把代码复制进去，然后更改里面的那两行绝对路径为word文件所在文件夹，运行，就可以在word文件的同目录生成同名的.txt文件了。.doc / .docx 文件都可以实现转换。</p><p>估计也就人工制作有标记数据的可怜人能用的上了吧(允悲)</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 第二次上机</title>
    <link href="/2022/03/10/ds-2/"/>
    <url>/2022/03/10/ds-2/</url>
    
    <content type="html"><![CDATA[<p>本周上机的难点主要在结构体和排序上面。</p><h1 id="结构体表示方法"><a href="#结构体表示方法" class="headerlink" title="结构体表示方法"></a>结构体表示方法</h1><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>一般来说，结构体是这么定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> </span><br><span class="hljs-class">//<span class="hljs-keyword">struct</span>：表示你即将定义一个与<span class="hljs-title">int</span>、<span class="hljs-title">char</span>、<span class="hljs-title">long</span> <span class="hljs-title">long</span> 相平行的一个【数据类型】</span><br><span class="hljs-class">//<span class="hljs-title">Node</span>:</span> 表示你定义的这个【数据类型】，也就是结构体，叫做Node。首字母大写只是程序员的习惯，不是必须的。<br>&#123;<br>    <span class="hljs-comment">//将以下的“成员” 打包在一起，作为这个数据类型</span><br>    <span class="hljs-comment">//这第四题的实例</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<span class="hljs-comment">//这个order的作用在下面的“让快排变稳定”会用到</span><br>&#125;;<br><br>Node n;<br><span class="hljs-comment">//声明结构体的方法：【数据类型】+【结构体的名字】，这个可以类比&quot; int num; &quot; 来理解</span><br>Node *p;<br><span class="hljs-comment">//声明一个结构体指针，这里可以类比&quot; int *a; &quot; 来理解</span><br><span class="hljs-comment">//指针经常习惯性地叫它p，是pointer的简称</span><br>Node *ptr[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<br>&#125; n, *p, *ptr[<span class="hljs-number">100</span>];<span class="hljs-comment">//注意，声明部分出现在分号前面</span><br></code></pre></td></tr></table></figure><p>结构体与 int，long long，等数据类型相同，它们声明完就可以直接开始赋值。而结构体【指针】的赋值等等操作之前，必须要先为它分配一个空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br></code></pre></td></tr></table></figure><p>结构体是这么访问的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构体</span><br>n.order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = n.order;<span class="hljs-comment">//读取</span><br><span class="hljs-comment">//结构体指针</span><br>p-&gt;order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = p-&gt;order;<span class="hljs-comment">//读取</span><br></code></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>要是头铁也可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//这是第五题的实例</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">505</span>][<span class="hljs-number">200</span>];<br><span class="hljs-type">char</span> author[<span class="hljs-number">505</span>][<span class="hljs-number">23</span>];<br><span class="hljs-type">char</span> loc[<span class="hljs-number">505</span>][<span class="hljs-number">33</span>];<br><span class="hljs-type">char</span> date[<span class="hljs-number">505</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//前四行看作是结构体内部的成员</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">505</span>];<span class="hljs-comment">//这一行看作是结构体指针</span><br></code></pre></td></tr></table></figure><p>book[505] 相当于505个结构体指针，那要怎么访问呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如我们要写入book[0]的信息</span><br>book[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//相当于第一位的书是“0号书”</span><br>name[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;harryPotter&quot;</span>;<br>author[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;JK&quot;</span>;<br>loc[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;London&quot;</span>;<br>date[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;2000&quot;</span>;<br><span class="hljs-comment">//访问同理</span><br></code></pre></td></tr></table></figure><p>book[0] = 0; 看似很多余。但是由于后续涉及到排序，以后book[0]，也就是排在最前面的书，就未必是0号书了。比如如果一顿排序，排在最前面的书是7号书，则此时book[0]==7。假设这本0号书在排序过后，排在了第三位，也就是book[2]==0; 则有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, name[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;harryPotter&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, author[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;JK&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, loc[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;London&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, date[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;2000&quot;</span><br></code></pre></td></tr></table></figure><p>这么表示感觉会抽象很多，代码的可读性也更差，但有个好处，就是访问的速度比较快。曾几何时，数据结构课的大作业是需要竞速的，此时，要想卷性能分，就会采用这种方式写结构体。</p><h1 id="结构体的排序"><a href="#结构体的排序" class="headerlink" title="结构体的排序"></a>结构体的排序</h1><h3 id="如何交换"><a href="#如何交换" class="headerlink" title="如何交换"></a>如何交换</h3><p>回忆int 类型的数据如何交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>而结构体理论上也可以通过这种方式进行直接赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Node a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>但是这样交换太不优雅了，那么庞大的数据，说复制就复制，说覆盖就覆盖。所以，一般采用指针进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>&#125;<br>Node *a, *b, *tmp;<br>a = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>b = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br><span class="hljs-comment">//……</span><br><br><span class="hljs-keyword">if</span>( a-&gt;num &lt; b-&gt;num )&#123;<span class="hljs-comment">//如果要交换的话</span><br>    tmp = b;<br>    b = a;<br>    a = b;<br>&#125;<br></code></pre></td></tr></table></figure><p>知道了怎么交换，就可以自己写冒泡排序啦。</p><h3 id="如何让快排变稳定"><a href="#如何让快排变稳定" class="headerlink" title="如何让快排变稳定"></a>如何让快排变稳定</h3><p>众所周知，快排是一个不稳定的排序，也就是说，当被比较的两个元素被认为大小相等时，它们两个在被排序之后的顺序是不确定的。</p><p>而本次作业，涉及到了排序稳定性的问题。当然，此时直接自己写一个冒泡排序完全可以，但是<del>qsort实在是太好用了</del>。这里简单讲讲如何实现稳定的快排。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">//以下代码是第四题实例的排序，忘了这些变量名是什么含义的话，请往上翻一翻</span><br>    qsort(ptr,n,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node *),cmp); <span class="hljs-comment">//n表示有几本书</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *b)</span><br>&#123;<br>    <span class="hljs-type">int</span> i=*(<span class="hljs-keyword">struct</span> Node *)a,j=*(<span class="hljs-keyword">struct</span> Node *)b;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name) != <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name);<br>    <span class="hljs-keyword">if</span> (i-&gt;order &gt; j-&gt;order ) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//这里用升序的写法，假装它是稳定的</span><br>    <span class="hljs-keyword">if</span> (i-&gt;order &lt; j-&gt;order ) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>order 即为顺序，首先，在输入每一个人的时候，为每一个结构体的order赋初值，也就是1、2、3、4、5……第i个录进来的，就为它的order赋值为i。</p><p>然后让order成为cmp（比较函数）中【权重较低】的那个。</p><p>这样，order较低（也就是较早被录入）的人，就会被排在前面，从而实现了稳定的qsort。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 第一次上机</title>
    <link href="/2022/03/03/ds-1/"/>
    <url>/2022/03/03/ds-1/</url>
    
    <content type="html"><![CDATA[<p>题目总体很程设，这里主要给出三道题的参考代码</p><h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h1><p>可以用层次化的思维去理解表达式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 +或- 项 +或- 项项 = 因子 *或/ 因子 *或/ 因子</code></pre></div><p>这样一来就可以考虑写个递归完成它。</p></space><p>当然还有一种更优雅的处理加减的方式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 + 项 + 项项 = +/- (因子 */ 因子 */ 因子)</code></pre></div><p>这样一来，在项结算的时候乘以1或-1，于是表达式只需要无脑加就可以了，思维量减小不少。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span><br>&#123;<br>    <span class="hljs-comment">//……</span><br>        <span class="hljs-comment">//如果发现是减</span><br>        <span class="hljs-keyword">return</span> num * sign + cal(<span class="hljs-number">-1</span>);<span class="hljs-comment">//传入的参数就是sign</span><br>    <span class="hljs-comment">//……</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>再优雅一点，可以把重复使用功能写成一个函数，比如下文的getNum()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span> <span class="hljs-comment">//用sign来标记这一项是正是负，也就是它的前面是加是减</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp;<br><span class="hljs-type">int</span> flag; <span class="hljs-comment">//用来标记计算方式， 1 为 * , 2 为 /</span><br><br><span class="hljs-comment">//项的开头必然是数字，所以先赋值一个数字</span><br>num = getNum();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//收尾部分：如果这一项结束了，进入收尾代码</span><br><br>        <span class="hljs-comment">//收尾代码</span><br><br><span class="hljs-comment">//循环部分：各种乘除</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[step]))<br>&#123;<br>tmp = getNum();<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>num *= tmp;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>num /= tmp;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br>            step++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">2</span>;<br>            step++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题有一点难想的部分可能就是：如何在获得因子之后，知道它与前面数字的计算是乘是除。代码中已经给了一个还不错的方法。</p><p>每进一步，都及时地进行计算，这样拿在手上的数字就不会太多，也会比较好想。</p><p>要是还想再优雅一点，由于项对每个因子的计算都是乘法/除法，而1*任何数字还是其本身，所以可以不为项的第一个因子写getNum()，而直接进入“标准化作业”。想想看怎么写吧。</p><p>掌握对表达式的层次化理解，非常有助于自己编程思维的形成。以后必然会出现涉及括号的表达式计算，有兴趣的同学也可以想想要怎么实现。</p><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><p>就是模拟竖式减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-type">void</span> <span class="hljs-title function_">jian</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> l1 = <span class="hljs-built_in">strlen</span>(s);    <span class="hljs-comment">//字符串长度 </span><br>    <span class="hljs-type">int</span> l2 = <span class="hljs-built_in">strlen</span>(ss);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;         <span class="hljs-comment">//一个记录正负的变量（后面就知道啦） </span><br><br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));       <br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));  <br><br>    <span class="hljs-keyword">if</span> ( l1 &lt; l2 || (<span class="hljs-built_in">strcmp</span>(s,ss) &lt; <span class="hljs-number">0</span> &amp;&amp; l1 == l2) )    <span class="hljs-comment">//这个比较重要是来判断前后两数的大小的  </span><br>    &#123;                                           <span class="hljs-comment">//不然一个小的数减一个大的数是大于零的就尴尬了</span><br>        flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里是把正负记录下来  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)    <span class="hljs-comment">//倒过来输入 </span><br>            a[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;      <span class="hljs-comment">//将字符串里的字符转换为数字 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)   <span class="hljs-comment">//同理，倒过来输入 </span><br>            a[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 &gt; l2) <br>        len = l1;             <span class="hljs-comment">//len赋值为其中大的数 </span><br>    <span class="hljs-keyword">else</span> <br>        len = l2; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++)<br>    &#123;<br>        a[i] = a[i] - b[i];     <span class="hljs-comment">//运算 </span><br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//如果减得多了 </span><br>        &#123;<br>            a[i+<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span>;         <span class="hljs-comment">//向前要一位 </span><br>            a[i]+=<span class="hljs-number">10</span>;          <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (a[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; len&gt;<span class="hljs-number">1</span>) len--;   <span class="hljs-comment">//while去零法，了解一下（名字现编的，别搜百度了） 这个&amp;&amp;len&gt;1 很重要，防止结果为0 不输出。</span><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);     <span class="hljs-comment">//如果结果是负的，先输出一个负号 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span> ;i &gt;= <span class="hljs-number">0</span> ;i--)   <span class="hljs-comment">//再输出结果 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <span class="hljs-comment">//换行 </span><br>&#125;                           <span class="hljs-comment">//高精度减法你懂了吗？ </span><br></code></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>把求全排列想象成：手上有 1~n n张数字卡片，依次放入编号为1~n的盒子里面。用book[]数组记录某个卡片是否被使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">fullArray(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> n)<br>&#123;<br><br>    <span class="hljs-comment">//收尾情况的代码：盒子放满后，进入收尾代码</span><br>    <span class="hljs-comment">//收尾代码：逐一打印数字卡片</span><br><br>    <span class="hljs-comment">//递归部分的代码：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//每一步都从最小的开始尝试放数字</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (book[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">//如果还没有被用</span><br>        &#123;<br>            a[step] = i;      <span class="hljs-comment">//用一个数组装卡片，放下数字卡片</span><br>            book[i] = <span class="hljs-number">1</span>;      <span class="hljs-comment">//表明放下的数字卡片被占用</span><br>            fullArray(step + <span class="hljs-number">1</span>, n); <span class="hljs-comment">//开始下一步</span><br>            book[i] = <span class="hljs-number">0</span>;      <span class="hljs-comment">//取回数字卡片</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于官方数字量不大，非要打表也不是不行（误）。</p><p>看到这里，就关掉网页自己写一遍吧。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. 开始</title>
    <link href="/2022/02/26/beginning/"/>
    <url>/2022/02/26/beginning/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>数据结构系列博客 旨在帮助北航2022信息类数据结构课的同学们，提供（与CSDN相比）质量较好的代码。博客内容包含数据结构中涉及的算法、数据结构模板，以及部分知识的讲解，并提供<del>充分的</del>注释以供同学们参考学习。  </p><p>代码主要来自个人作业以及个人笔记，且本人水平有限，代码风格欠佳，故不保证正确性，如发现有问题，或有更好的补充，欢迎在评论区指正，本人必及时修改。</p><p>本博客与课程进度（大概）同步更新。</p><h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><ol><li>数据结构课的作业、考试均在自己的电脑上完成，所以非常建议大家转用vs code，界面好看功能多，调试更友好。</li><li> vs code 下，ctrl＋alt＋F（dev C++ 下，ctrl＋shift<br>＋A）可以格式化代码，让代码更好读，也有助于助教解答。</li><li>judge平台可以进行在线答疑，会有助教轮班解答。</li><li>推荐书籍：《啊哈算法》、《大话数据结构》，两本书基本覆盖数据结构课程内容。</li><li>数据结构的题目都很经典，一般在网上就可以找到完全匹配的算法。所以实在不会可以试着百度一下题干。</li></ol><h1 id="特别警告"><a href="#特别警告" class="headerlink" title="特别警告"></a>特别警告</h1><p>数据结构课程组<strong>十分重视抄袭问题！系统会对提交的代码进行查重！</strong>故<strong>万万不可复制博客中的代码</strong>，也尽量不要对着博客写代码，防止被 认定/误认定 为抄袭。博客中的代码仅供参考，作业中的代码烦请自行书写。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
