<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2022/03/26/OO-unit1/"/>
    <url>/2022/03/26/OO-unit1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将按照作业的顺序依次展示作业中的思路，以及个人认为比较有价值的代码。考虑到阅读体验，本文将圈复杂度分析放在了文末。</p><h1 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h1><h2 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h2><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133035239-1502470451.png"></p><p>整个表达式的处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133652693-478656214.png"></p><h2 id="空白符的处理"><a href="#空白符的处理" class="headerlink" title="空白符的处理"></a>空白符的处理</h2><p>空白符在一开始直接删去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> string.replaceAll(<span class="hljs-string">&quot;[ \\t]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>这一方法将延续三次作业</p><h2 id="简化方式"><a href="#简化方式" class="headerlink" title="简化方式"></a>简化方式</h2><h3 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h3><p>化简这一步的示意图如下：</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325141828163-1971151374.png"></p><p>在<code>expr.simplify()</code>这一步中，因子只能是x或常数，因此，在简化时，只需要递归地向上传一个<code>HashMap&lt;Biginteger, Biginteger&gt;</code>，在<code>term.simplify()</code>中，完成<code>HashMap&lt;Biginteger, Biginteger&gt;</code>之间相乘，在<code>expr.simplify()</code>中完成<code>HashMap&lt;Biginteger, Biginteger&gt;</code>的相加即可。其中，前面的Biginteger代表指数，后面的Biginteger代表系数。</p><h2 id="符号处理"><a href="#符号处理" class="headerlink" title="符号处理"></a>符号处理</h2><p>观察表达式的形式化表述：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">表达式 → 空白项 [加减 空白项] 项 空白项 <span class="hljs-string">| 表达式 加减 空白项 项 空白项</span><br>项 → [加减 空白项] 因子 <span class="hljs-string">| 项 空白项 * 空白项 因子</span><br></code></pre></td></tr></table></figure><p>可以发现，如果不考虑数量，所有的加减号理论上都可以认为是项（Term）前面的符号。因此，在符号处理上，在表达式处理流程的<code>parseExpr()</code>这一步中，符号将交由<code>Parser</code>中的<code>parseTerm()</code>方法开头处统一处理。</p><p>而带符号的整数中，发现Biginteger(string)的方法，可以处理string前的正负号，因此直接用这一函数处理。</p><p>这一处理方法将会延续整个第一单元。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>将<code>x**2</code>替换为<code>x*x</code>可以减少一个字符。处理方法为：在<code>printRes()</code>这一步中，对即将打印的<code>x**2</code>进行特判，并进行替换即可。</li><li><code>-x+1</code>这样负号在前的表达式，可换为<code>1-x</code>从而减小长度。处理方法为：遍历<code>HashMap&lt;Biginteger, Biginteger&gt;</code>的所有元素，找到系数为正数的项提前打印并删除，再将这个HashMap进行一般流程的打印。</li></ol><h1 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h1><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133101155-117133541.png"></p><p>表达式的整个处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325135159332-2023732794.png"></p><p>本次作业中，将第一次作业的表达式层次：<code>Expr-Term-Factor</code>改为<code>Expr-Term-Pow-Factor</code>。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>笔者对自定义函数的处理方式为<strong>字符串替换</strong>。字符串需要解决如下的问题：</p><h3 id="字符串替换不当导致语义变化"><a href="#字符串替换不当导致语义变化" class="headerlink" title="字符串替换不当导致语义变化"></a>字符串替换不当导致语义变化</h3><p>笔者的解决方法是：能加括号的地方尽可能加括号。</p><p>由于采用层次化的方法解析表达式，因此再深的括号，这个程序架构都能够充分展开，因此，能加括号的地方尽可能加括号并不会带来错误。</p><h3 id="形参为x时，替换可能出bug"><a href="#形参为x时，替换可能出bug" class="headerlink" title="形参为x时，替换可能出bug"></a>形参为x时，替换可能出bug</h3><p>对于自定义函数，由于自定义函数中的参数x、y、z出现的顺序不固定，且形参复用了自变量<code>x</code>这一字母。于是，如果直接进行字符串的替换，会误将自变量<code>x</code>当作形参<code>x</code>进行替换而出错。</p><p>对此，笔者的方法是：在<code>parseFunct()</code>这一步，将自定义函数的参数<strong>依次</strong>换为p、q、l这三个在整个流程中未使用的字母，这样就不用担心字符串替换时出错了。而后续替换，也将每一个形参替换为传入的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String[] letter = &#123; <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;p&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>而参数的匹配，采用的是正则表达式匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (funct.getCnt()) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*),(.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                pattern = <span class="hljs-string">&quot;[fgh]\\((.*),(.*),(.*)\\)$&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Pattern.compile(pattern);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> tmp.matcher(ori);<br>        <span class="hljs-keyword">if</span> (matcher.find()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; funct.getCnt(); i++) &#123;<br>                functString = functString.replaceAll(letter[i], <span class="hljs-string">&quot;(&quot;</span> + matcher.group(<span class="hljs-number">1</span> + i) + <span class="hljs-string">&quot;)&quot;</span>);<br>                <span class="hljs-comment">// not sure</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h2><p>求和函数的处理同样是<strong>利用正则表达式匹配，并替换字符串</strong>。唯独需要注意的是，sin函数中也有“i”字符，进行替换的时候要当心不要将其换为常数。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">termString</span> <span class="hljs-operator">=</span> exp.replaceAll(<span class="hljs-string">&quot;(?&lt;!s)i&quot;</span>, <span class="hljs-string">&quot;(&quot;</span> + i + <span class="hljs-string">&quot;)&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="计算顺序的问题"><a href="#计算顺序的问题" class="headerlink" title="计算顺序的问题"></a>计算顺序的问题</h3><p>由于设计展开括号的时候，</p><h2 id="简化方式-1"><a href="#简化方式-1" class="headerlink" title="简化方式"></a>简化方式</h2><p>本次简化分为两步：展开括号（expand），进行合并（simplify）。</p><h3 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h3><p>流程示意图如下：<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325150902692-2022730891.png"></p><p>由于因子不再是只有数字和x了，因此向上传递<code>HashMap</code>不再行得通。因此，采用向上传递<code>ArrayList&lt;Term&gt;</code>的方式进行括号的展开。</p><h3 id="simplify"><a href="#simplify" class="headerlink" title="simplify"></a>simplify</h3><p>对项，需要将<code>Pow</code>类底数<code>base</code>相同的因子合并，且指数相加。</p><p>对表达式，需要识别除系数外相同的项<code>term</code>，并将其系数<code>coe</code>相加。</p><p>此时，考虑采用重写<code>HashCode()</code>和<code>equals()</code>方法，并利用<code>HashSet&lt;&gt;</code>的元素不可重复性。</p><p>大致的流程为：</p><p>在项中：将<code>ArrayList&lt;Pow&gt;</code>的每个元素逐一放入<code>HashMap&lt;Factor, BigInteger&gt;</code>中，若<code>Factor</code>为数字，则乘入系数<code>coe</code>中；若出现相同的<code>Factor</code>，则指数改为两者指数之和。最后删去指数为0的对。</p><p>在表达式中：将<code>ArrayList&lt;Term&gt;</code>的每个元素逐一放入<code>HashMap&lt;HashSet&lt;Pow&gt;,BigInteger&gt;</code>中，其中value为系数<code>coe</code>。若出现相同的<code>HashSet&lt;Pow&gt;</code>，则系数改为两者系数之和。最后删去系数为0的对。</p><p>由于化简之前已经进行了括号的展开<code>expand</code>，故不会出现<code>x</code>和<code>(x)</code>无法被认为相等的情况。（因为此时根本不会出现<code>(x)</code>）。</p><h2 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="奇偶优化"><a href="#奇偶优化" class="headerlink" title="奇偶优化"></a>奇偶优化</h3><p>由于cos、sin函数具有奇偶性，因此，无脑将cos、sin中的符号提出，至少是不会增加结果的长度的。</p><p>实现方法为：在<code>simplify()</code>这一步中，判断一下三角函数内因子的符号，如果为负，则改为正，并向外传递一个信号，<code>Term</code>类接到这个信号后，系数*-1即可。</p><h3 id="三角函数原点的值"><a href="#三角函数原点的值" class="headerlink" title="三角函数原点的值"></a>三角函数原点的值</h3><p>将sin(0)换为0，cos(0)换为1可以缩短结果长度。方法为：在<code>simplify()</code>这一步时，对三角函数里面的内容进行判断。若为0，则将<code>Pow</code>的底数<code>base</code>替换为数字类<code>Number</code>，其值与原三角函数相同。</p><h2 id="答案输出"><a href="#答案输出" class="headerlink" title="答案输出"></a>答案输出</h2><p>第二次作业中，答案字符串的复杂度要远远高于第一次作业，如果和第一次作业一样，在main函数写<code>printRes()</code>方法，那么这一方法的长度必然会超标。因此，本次作业改为采用在各个层次各自递归下降地<code>toString()</code>方法，并进行拼合。</p><p>由于数据限制，sin、cos中的<code>Term</code>在输出答案时，<code>x**2</code>不能被替换为<code>x*x</code>，故为sin、cos中的<code>Term</code>定制了一个转为字符串的方法<code>display()</code>，以满足题目要求。</p><h2 id="出现的bug"><a href="#出现的bug" class="headerlink" title="出现的bug"></a>出现的bug</h2><ol><li>由于之前一直采用<code>Biginteger(string)</code>的方式处理常数，可省去特判数字前的符号这一步骤。因此疏忽了数字前面可能会出现”+”。故并没有在匹配求和函数上下限时考虑数字前的“+”，导致正则表达式匹配求和函数时匹配失败。解决方法为：修正正则表达式，使其可以匹配”+”。</li><li>在奇偶优化时，未考虑三角函数的指数为偶数时，Term不应该*-1，导致出bug。解决方法为：将“如果为负，则改为正，并向外传递一个信号”改为“如果为负，则改为正，若三角函数指数为奇数，则向外传递一个信号”。</li><li>未进行深拷贝，导致项与项相乘时出错。</li></ol><h1 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h1><p>类图如下<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325133113128-1744181138.png"></p><p>表达式的整个处理流程大致如下图</p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325135159332-2023732794.png"></p><h2 id="三角函数的处理"><a href="#三角函数的处理" class="headerlink" title="三角函数的处理"></a>三角函数的处理</h2><p>由于三角函数中的因子限制放宽，因此在三角函数的化简过程有较大变化。三角函数sin、cos中的内容由常数或幂函数变为了一般的因子。笔者选择了<strong>直接按照表达式</strong>处理。</p><p>为了能充分复用第二次作业的代码，本次作业虽然将三角函数内的因子按表达式处理，但在expand这一步提前对三角函数内的表达式进行了<code>expr.simplify()</code>，并进行判断：若<code>Expr</code>只有唯一的项，且项的结果相当于常数或幂函数（即不需要加括号），则将表达式中唯一的项复制到<code>Sin</code>、<code>Cos</code>类里面的<code>Term</code>类属性中，并在<code>toString</code>的步骤中，按第二次作业的方法处理。反之，保留这个<code>Expr</code>类变量，在<code>toString</code>的步骤中，按表达式处理。</p><p>这里展示<code>toString()</code>方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (term.getFinalPows().isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + term.display() + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (term.getPows().get(<span class="hljs-number">0</span>).getBase() <span class="hljs-keyword">instanceof</span> X<br>                &amp;&amp; term.getPows().get(<span class="hljs-number">0</span>).getExp().equals(BigInteger.valueOf(<span class="hljs-number">2</span>))) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + <span class="hljs-string">&quot;x**2&quot;</span> + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos(&quot;</span> + term.display() + <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cos((&quot;</span> + expr.toString() + <span class="hljs-string">&quot;))&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简化方式-2"><a href="#简化方式-2" class="headerlink" title="简化方式"></a>简化方式</h2><p>简化分为两步：展开括号（expand），进行合并（simplify）。</p><h3 id="expand-1"><a href="#expand-1" class="headerlink" title="expand"></a>expand</h3><p>示意图如下：<br><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220325154222905-933010666.png"></p><p>大部分与第二次作业一致，除了三角函数类里增加了<code>Expr</code>类指令，并在<code>expand</code>的步骤中提前进行了<code>simplify</code>这一步。</p><h3 id="simplify-1"><a href="#simplify-1" class="headerlink" title="simplify"></a>simplify</h3><p>同作业二。</p><h2 id="性能优化-2"><a href="#性能优化-2" class="headerlink" title="性能优化"></a>性能优化</h2><p>本次作业未做额外的优化，优化方式同作业二。</p><h2 id="求和函数的参数替换"><a href="#求和函数的参数替换" class="headerlink" title="求和函数的参数替换"></a>求和函数的参数替换</h2><p>由于此时数据限制放宽，之前使用正则表达式提取参数将无法应对如<code>f(sum(i,1,2,(x)**2),((((x)))))</code>这样刁钻的数据。此时，考虑通过括号堆栈的方式，找到每一个逗号间隔内的内容。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">groupBegin[<span class="hljs-number">0</span>] = start + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">Funct</span> <span class="hljs-variable">funct</span> <span class="hljs-operator">=</span> functs.get(type);<br>        <span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> lexer.getchar(end);<br>            <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>                num++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>                num--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (now.equals(<span class="hljs-string">&quot;,&quot;</span>) &amp;&amp; num == <span class="hljs-number">1</span>) &#123;<br>                groupEnd[k] = end;<br>                k++;<br>                groupBegin[k] = end + <span class="hljs-number">1</span>;<br>            &#125;<br>            end++;<br>        &#125;<br>        groupEnd[k] = end - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="出现的bug-1"><a href="#出现的bug-1" class="headerlink" title="出现的bug"></a>出现的bug</h2><ol><li>版本迭代的时候没有注意到求和函数<code>sum</code>的求和上限与下限并没有明确的大小限制，因此在写的时候用<code>int</code>型的变量去装上下限了。爆栈的数据在第二、三次作业的中、强测中均未出现，因此并没有修改这一bug，而在互测环节被hack了。</li></ol><h1 id="圈复杂度分析"><a href="#圈复杂度分析" class="headerlink" title="圈复杂度分析"></a>圈复杂度分析</h1><h2 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135514037-2121458312.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135535589-1046267560.png"></p><h2 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135706474-670960018.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135718167-653735896.png"></p><p>由于Cal类中的方法，只在Term类中被使用。因此，如果将Cal中的方法直接写在Term里面，就可以少一个类，可以降低圈复杂度。</p><h2 id="第三次作业-1"><a href="#第三次作业-1" class="headerlink" title="第三次作业"></a>第三次作业</h2><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135725010-480457731.png"></p><p><img src="https://img2022.cnblogs.com/blog/2785182/202203/2785182-20220326135732991-399532382.png"></p><p>equals函数的圈复杂度这么高，好像也是没有办法。</p><p>这个阶段的作业由于不敢将原来的方法改写，想要实现新的功能时，就会重写一个方法，增加一些不必要的属性。可能这就是屎山的诞生吧。</p><h1 id="hack思路"><a href="#hack思路" class="headerlink" title="hack思路"></a>hack思路</h1><ol><li>常数： 考虑前导零和正负号的处理是否正确</li><li>幂函数：考虑零次方的结果是否恒为1，考虑项的合并是否正确。考虑偶次幂消去负号的这一步是否正确。</li><li>求和函数：考虑求和上下限是否支持正负，是否支持上限小于上限。考虑正负号的代入是否正确。</li><li>三角函数：考虑三角优化是否正确，考虑正负号的优化是否正确，考虑多层三角函数嵌套是否支持。</li><li>自定义函数：考虑参数的替换是否正确，考虑形参的顺序是否会干扰代入。</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>第一周的OO大主题为表达式的解析，整个作业的走向基本是可以预见到的。但是在实际书写的过程中，还是无法在一开始就想好以后的通用度问题，数据的覆盖面上，也比较依赖评测机。比如第二次作业相第三次作业迭代的时候，原以为第二次作业做的一些超前的工作，可以直接应付第三次作业，但是在开放中测后还是发现了很多问题，重写了不少代码。这一点可能还是个人能力不足。</p><p>以及，个人也曾立志要好好写一个数据生成程序和自动评测程序，但最后还是没写，白嫖了讨论区……</p><p>总体上还是有收获的吧，也有一些遗憾，希望以后能写得更好。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 第三次上机</title>
    <link href="/2022/03/24/ds-3/"/>
    <url>/2022/03/24/ds-3/</url>
    
    <content type="html"><![CDATA[<h1 id="连续线段"><a href="#连续线段" class="headerlink" title="连续线段"></a>连续线段</h1><p>对于每一个连续线段，其有用的信息只有：左右端点坐标、连续线段中的端点数。</p><p>因此可以考虑做一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">line</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> lx,ly,rx,ry,length;<br>&#125;line[<span class="hljs-number">105</span>];<br></code></pre></td></tr></table></figure><p>每输入一个新线段(x1,y1) (x2,y2)，都与现存的每个line的左右端点相比较，如果有重合的，则延长；如果没有，就开一条新的line存放这个线段。</p><h1 id="猴子选大王"><a href="#猴子选大王" class="headerlink" title="猴子选大王"></a>猴子选大王</h1><p>是一个经典的约瑟夫环问题。这个网上讲解很多，我就不重复造轮子了。</p><p>推荐教程：<a href="https://blog.csdn.net/qie_wei/article/details/87915174">https://blog.csdn.net/qie_wei/article/details/87915174</a></p><p>贴一下码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i, m, n, q, a = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        a = (a + m) % i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (a + q - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面用的是公式法，当然用链表也是完全可以解题的。鉴于大家刚学链表，还是比较推荐大家用链表写。</p><h1 id="多项式相乘"><a href="#多项式相乘" class="headerlink" title="多项式相乘"></a>多项式相乘</h1><p>我们要开始接触链表啦！<br>一个经典的链表长这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//一些结点内的数据：</span><br>    <span class="hljs-type">int</span> c;<span class="hljs-comment">//c即系数coe</span><br>    <span class="hljs-type">int</span> e;<span class="hljs-comment">//e即指数exp</span><br>    <span class="hljs-comment">//连向下一个结点的指针：</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;*head;<span class="hljs-comment">//经常会有一个全局的链表头结点指针</span><br></code></pre></td></tr></table></figure><p>关于这个head，市面上有两种风格。</p><p>一个是：head是第一个有数据的结点；</p><p>另一个是：head-&gt;next 指向第一个有数据的结点。</p><p>选用哪一种全看个人习惯，本人采用第一种。</p><p>对于链表的经典操作有以下几种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *head)</span> <span class="hljs-comment">//反转链表</span><br>&#123;<br>    p = head-&gt;next;<br>    q = <span class="hljs-literal">NULL</span>;<br>    r = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        q = p;<br>        p = p-&gt;next;<br>        q-&gt;next = r;<br>        r = q;<br>    &#125;<br>    head-&gt;next = p;<br>    p-&gt;next = q;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//链接之前需要一个全局变量头指针。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">head</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">addNode</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e)</span> <span class="hljs-comment">//连接下一个结点，一开始扫入用</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">q</span>;</span><br>    q = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    q-&gt;c = c;<br>    q-&gt;e = e;<br>    q-&gt;next = head-&gt;next;<br>    head-&gt;next = q;<br>    head = q;<br>    <span class="hljs-comment">//仔细理解一下这个链接的过程，并想想为什么这个函数结束后，q被杀掉了也没关系？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e)</span> <span class="hljs-comment">//插入一个结点</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>, *<span class="hljs-title">r</span>;</span><br>    q = head;<br>    <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;e &gt; e) <span class="hljs-comment">//这里其实可以根据题目的需要，换成其他条件</span><br>    &#123;<br>        p = q;<br>        q = q-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//到了链表尾，在尾后加结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = <span class="hljs-literal">NULL</span>;<br>        q-&gt;next = r;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;e == e) <span class="hljs-comment">//满足一定条件，改变原有结点而不插入新结点</span><br>        q-&gt;c += c;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q-&gt;e &lt; e &amp;&amp; q != head)<span class="hljs-comment">//在链表中间插结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = q;<br>        p-&gt;next = r;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q==head)<span class="hljs-comment">//在头前面插结点</span><br>    &#123;<br>        r = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        r-&gt;c = c;<br>        r-&gt;e = e;<br>        r-&gt;next = q;<br>        head = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，我们应该就可以把输入的两个表达式做成链表存起来了。</p><p>具体实现已经被上面这些写得差不多啦，这里写一下实现的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//扫入第一个表达式，形成第一条链表</span><br>    <span class="hljs-comment">//扫入第二个表达式，形成第二条链表</span><br>    <span class="hljs-comment">//新建一个存答案的空链表</span><br>    <span class="hljs-keyword">for</span>()<span class="hljs-comment">//对第一个链表的每个项</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>()<span class="hljs-comment">//乘以第二个链表的每个项</span><br>        &#123;<br>            <span class="hljs-comment">//两项相乘得到新的项</span><br>            <span class="hljs-comment">//把新的项插入存答案的链表中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//打印答案链表</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h1><p>和上一题差不多，但是链表的结尾不再是NULL，而是指向head。</p><p>链表需要一个新功能：删除某个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假设初始的链接状态下：</span><br><span class="hljs-comment">p ==&gt; q ==&gt; r;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>    p-&gt;next = r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure><h1 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h1><p>和前面的题性质差不多，我就直接贴我当年的代码了，只可参考，不可复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> word[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> time;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; * head, *p, *q, *r;<br><span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span><br>&#123;<br>    q = head;<br>    <span class="hljs-keyword">while</span> (q-&gt;next != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        q = q-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d\n&quot;</span>, q-&gt;word, q-&gt;time);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *p)</span><br>&#123;<br><br>    q = head;<br>    r = q;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            p-&gt;next = <span class="hljs-literal">NULL</span>;<br>            r-&gt;next = p;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;word, p-&gt;word) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            r = q;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(q-&gt;word, p-&gt;word) &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                r-&gt;next = p;<br>                p-&gt;next = q;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q-&gt;time++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">500</span>];<br>    <span class="hljs-type">int</span> i, j, len;<br>    head = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    head-&gt;word[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    FILE *in;<br>    <span class="hljs-keyword">if</span> ((in = fopen(<span class="hljs-string">&quot;article.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (fgets(s, <span class="hljs-number">200</span>, in) != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            len = <span class="hljs-built_in">strlen</span>(s);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || <span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>                &#123;<br>                    p = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>                    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>                    p-&gt;time = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; <span class="hljs-string">&#x27;a&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || <span class="hljs-string">&#x27;A&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>;)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br><br>                        &#123;<br>                            s[i] = s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>                        &#125;<br>                        p-&gt;word[j] = s[i];<br>                        i++;<br>                        j++;<br>                    &#125;<br>                    p-&gt;word[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                    insert(p);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        print();<br>    &#125;<br>    fclose(in);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>代码查重工作近期要开始啦，助教会亲自审判查重率高的同学，所以注意不要copy！！！</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word文档转txt小程序</title>
    <link href="/2022/03/13/doc2txt/"/>
    <url>/2022/03/13/doc2txt/</url>
    
    <content type="html"><![CDATA[<p>麻了，网上的word文档转txt的代码没有一个能跑的。要不然就是通用性极差，得专门按序号命名才行。</p><p>这里缝合了两个doc2txt的python代码，以期中文互联网上多一份能跑的代码。</p><p>跑之前要先安装win32com，在cmd下输入：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">python -m pip install pypiwin32<br></code></pre></td></tr></table></figure><p>以下为完整代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> win32com.client<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_word_to_txt</span>(<span class="hljs-params">word_path, save_path</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;读取&#x27;</span>+word_path)<br>    word = win32com.client.Dispatch(<span class="hljs-string">&#x27;Word.Application&#x27;</span>)  <span class="hljs-comment"># 调用word应用</span><br>    doc = word.Documents.Open(word_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存中。。。&#x27;</span>)<br>    doc.SaveAs(save_path, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 保存格式为txt</span><br>    doc.Close()<br>    word.Quit()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_doc</span>():<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\a1271\Desktop\\脱敏-ID, PHONE, NAME，文件名\\脱敏-ID, PHONE, NAME，文件名\\*.doc&#x27;</span>):<span class="hljs-comment"># 要读取的.doc文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> glob.glob(<span class="hljs-string">&#x27;C:\\Users\\a1271\Desktop\\脱敏-ID, PHONE, NAME，文件名\\脱敏-ID, PHONE, NAME，文件名\\*.docx&#x27;</span>):<span class="hljs-comment"># 要读取的.docx文件路径</span><br>        <span class="hljs-keyword">yield</span> d<br><br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> next_doc():<br>    name, ext = os.path.splitext(doc)<br>    readPath = doc <br>    savePath =name+<span class="hljs-string">&quot;.txt&quot;</span>  <span class="hljs-comment"># 保存的绝对路径，这里默认转到相同路径</span><br>    change_word_to_txt(readPath, savePath)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;保存成功！&#x27;</span>)<br></code></pre></td></tr></table></figure><p>只需要新建一个.py文件，把代码复制进去，然后更改里面的那两行绝对路径为word文件所在文件夹，运行，就可以在word文件的同目录生成同名的.txt文件了。.doc / .docx 文件都可以实现转换。</p><p>估计也就人工制作有标记数据的可怜人能用的上了吧(允悲)</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 第二次上机</title>
    <link href="/2022/03/10/ds-2/"/>
    <url>/2022/03/10/ds-2/</url>
    
    <content type="html"><![CDATA[<p>本周上机的难点主要在结构体和排序上面。</p><h1 id="结构体表示方法"><a href="#结构体表示方法" class="headerlink" title="结构体表示方法"></a>结构体表示方法</h1><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>一般来说，结构体是这么定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> </span><br><span class="hljs-class">//<span class="hljs-keyword">struct</span>：表示你即将定义一个与<span class="hljs-title">int</span>、<span class="hljs-title">char</span>、<span class="hljs-title">long</span> <span class="hljs-title">long</span> 相平行的一个【数据类型】</span><br><span class="hljs-class">//<span class="hljs-title">Node</span>:</span> 表示你定义的这个【数据类型】，也就是结构体，叫做Node。首字母大写只是程序员的习惯，不是必须的。<br>&#123;<br>    <span class="hljs-comment">//将以下的“成员” 打包在一起，作为这个数据类型</span><br>    <span class="hljs-comment">//这第四题的实例</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<span class="hljs-comment">//这个order的作用在下面的“让快排变稳定”会用到</span><br>&#125;;<br><br>Node n;<br><span class="hljs-comment">//声明结构体的方法：【数据类型】+【结构体的名字】，这个可以类比&quot; int num; &quot; 来理解</span><br>Node *p;<br><span class="hljs-comment">//声明一个结构体指针，这里可以类比&quot; int *a; &quot; 来理解</span><br><span class="hljs-comment">//指针经常习惯性地叫它p，是pointer的简称</span><br>Node *ptr[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">char</span> num[<span class="hljs-number">14</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int</span> order;<br>&#125; n, *p, *ptr[<span class="hljs-number">100</span>];<span class="hljs-comment">//注意，声明部分出现在分号前面</span><br></code></pre></td></tr></table></figure><p>结构体与 int，long long，等数据类型相同，它们声明完就可以直接开始赋值。而结构体【指针】的赋值等等操作之前，必须要先为它分配一个空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br></code></pre></td></tr></table></figure><p>可能有同学第一次接触 malloc，也不明白什么叫“分配一个空间”。这里简单地讲解一下。</p><h4 id="malloc-与结构体指针"><a href="#malloc-与结构体指针" class="headerlink" title="malloc 与结构体指针"></a>malloc 与结构体指针</h4><p>先用int作一个类比讲解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> b;<br><span class="hljs-comment">//这条代码执行完之后，就分配好了一个int的空间</span><br><span class="hljs-type">int</span> *a;<br><span class="hljs-comment">//这条代码执行完之后，分配好了一个指针的空间</span><br>a = &amp;b;<br><span class="hljs-comment">//这条代码执行完之后，为a的内容写上b的地址，相当于让a指向b</span><br></code></pre></td></tr></table></figure><p>结构体同理。理论上也可以这么用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n</span>[100];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>[100];</span><br><br>ptr[<span class="hljs-number">0</span>] = &amp;n[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>但是这样未免太脑瘫了，我干嘛不直接用n，而去用ptr呢？</p><p>这是因为，在后续的章节，我们逐渐接触到树、链表等等数据结构之后，我们将实现用一个指针，去完成对一堆结构体的构建、查找、排序、删除。首先，我们就要学着用结构体指针 去操作一个【无名结构体】。</p><p>我们再回到刚才的代码。同样，我们用int进行类比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *a;<br><span class="hljs-comment">//这条代码执行完之后，分配好了一个指针的空间</span><br>a = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-comment">//这条代码执行完之后，为a的内容写上b的地址，相当于让a指向一个int大小的空间【的开头】。</span><br></code></pre></td></tr></table></figure><p>这样，我们就让int指针，指向了一个无名的int空间。</p><p>于是，为结构体指针“分配空间”，指的就是“为它指向的目的地分配一个结构体那么大的空间”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br></code></pre></td></tr></table></figure><p>而结构体是这么访问的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> <span class="hljs-title">n</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>;</span><br>ptr = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br><span class="hljs-comment">//结构体</span><br>n.order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = n.order;<span class="hljs-comment">//读取</span><br><br><span class="hljs-comment">//结构体指针</span><br>p-&gt;order = <span class="hljs-number">3</span>;<span class="hljs-comment">//写入</span><br><span class="hljs-type">int</span> a = p-&gt;order;<span class="hljs-comment">//读取</span><br></code></pre></td></tr></table></figure><p>为结构体指针分配空间至关重要，要是不做这一步的话，结构体指针的目的地就没有一个结构体那么大的空间，这个指针就相当于野指针。对它的访问和写入都是没有意义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">ptr</span>;</span><br>ptr-&gt;order = <span class="hljs-number">3</span>;<span class="hljs-comment">//这行代码会报错。</span><br></code></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>要是头铁也可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//这是第五题的实例</span><br><span class="hljs-type">char</span> name[<span class="hljs-number">505</span>][<span class="hljs-number">200</span>];<br><span class="hljs-type">char</span> author[<span class="hljs-number">505</span>][<span class="hljs-number">23</span>];<br><span class="hljs-type">char</span> loc[<span class="hljs-number">505</span>][<span class="hljs-number">33</span>];<br><span class="hljs-type">char</span> date[<span class="hljs-number">505</span>][<span class="hljs-number">6</span>];<span class="hljs-comment">//前四行看作是结构体内部的成员</span><br><span class="hljs-type">int</span> book[<span class="hljs-number">505</span>];<span class="hljs-comment">//这一行看作是结构体指针</span><br></code></pre></td></tr></table></figure><p>book[505] 相当于505个结构体指针，那要怎么访问呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如我们要写入book[0]的信息</span><br>book[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//相当于第一位的书是“0号书”</span><br>name[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;harryPotter&quot;</span>;<br>author[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;JK&quot;</span>;<br>loc[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;London&quot;</span>;<br>date[book[<span class="hljs-number">0</span>]] = <span class="hljs-string">&quot;2000&quot;</span>;<br><span class="hljs-comment">//访问同理</span><br></code></pre></td></tr></table></figure><p>book[0] = 0; 看似很多余。但是由于后续涉及到排序，以后book[0]，也就是排在最前面的书，就未必是0号书了。比如如果一顿排序，排在最前面的书是7号书，则此时book[0]==7。假设这本0号书在排序过后，排在了第三位，也就是book[2]==0; 则有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, name[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;harryPotter&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, author[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;JK&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, loc[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;London&quot;</span><br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, date[book[<span class="hljs-number">2</span>]]);<span class="hljs-comment">// 输出 &quot;2000&quot;</span><br></code></pre></td></tr></table></figure><p>这么表示感觉会抽象很多，代码的可读性也更差，但有个好处，就是访问的速度比较快。曾几何时，数据结构课的大作业是需要竞速的，此时，要想卷性能分，就会采用这种方式写结构体。</p><h1 id="结构体的排序"><a href="#结构体的排序" class="headerlink" title="结构体的排序"></a>结构体的排序</h1><h3 id="如何交换"><a href="#如何交换" class="headerlink" title="如何交换"></a>如何交换</h3><p>回忆int 类型的数据如何交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>而结构体理论上也可以通过这种方式进行直接赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Node a, b, tmp;<br>tmp = b;<br>b = a;<br>a = b;<br></code></pre></td></tr></table></figure><p>但是这样交换太不优雅了，那么庞大的数据，说复制就复制，说覆盖就覆盖。所以，一般采用指针进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>&#125;<br>Node *a, *b, *tmp;<br>a = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>b = (strunct Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br><span class="hljs-comment">//……</span><br><br><span class="hljs-keyword">if</span>( a-&gt;num &lt; b-&gt;num )&#123;<span class="hljs-comment">//如果要交换的话</span><br>    tmp = b;<br>    b = a;<br>    a = b;<br>&#125;<br></code></pre></td></tr></table></figure><p>知道了怎么交换，就可以自己写冒泡排序啦。</p><h3 id="如何让快排变稳定"><a href="#如何让快排变稳定" class="headerlink" title="如何让快排变稳定"></a>如何让快排变稳定</h3><p>众所周知，快排是一个不稳定的排序，也就是说，当被比较的两个元素被认为大小相等时，它们两个在被排序之后的顺序是不确定的。</p><p>而本次作业，涉及到了排序稳定性的问题。当然，此时直接自己写一个冒泡排序完全可以，但是<del>qsort实在是太好用了</del>。这里简单讲讲如何实现稳定的快排。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">//以下代码是第四题实例的排序，忘了这些变量名是什么含义的话，请往上翻一翻</span><br>    qsort(ptr,n,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node *),cmp); <span class="hljs-comment">//n表示有几本书</span><br><br><span class="hljs-comment">//可以看看这个地方是如何对指针进行排序的</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *a,<span class="hljs-type">const</span> <span class="hljs-type">void</span>   *b)</span><span class="hljs-comment">//一个\*！！</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">i</span> =</span> *(<span class="hljs-keyword">struct</span> Node **)a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">j</span> =</span> *(<span class="hljs-keyword">struct</span> Node **)b;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name) != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(i-&gt;name, j-&gt;name);<br>    <span class="hljs-keyword">if</span> (i-&gt;order &gt; j-&gt;order)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//这里用升序的写法，假装它是稳定的</span><br>    <span class="hljs-keyword">if</span> (i-&gt;order &lt; j-&gt;order)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>order 即为顺序，首先，在输入每一个人的时候，为每一个结构体的order赋初值，也就是1、2、3、4、5……第i个录进来的，就为它的order赋值为i。</p><p>然后让order成为cmp（比较函数）中【权重较低】的那个。</p><p>这样，order较低（也就是较早被录入）的人，就会被排在前面，从而实现了稳定的qsort。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 第一次上机</title>
    <link href="/2022/03/03/ds-1/"/>
    <url>/2022/03/03/ds-1/</url>
    
    <content type="html"><![CDATA[<p>题目总体很程设，这里主要给出三道题的参考代码</p><h1 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h1><p>可以用层次化的思维去理解表达式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 +或- 项 +或- 项项 = 因子 *或/ 因子 *或/ 因子</code></pre></div><p>这样一来就可以考虑写个递归完成它。</p></space><p>当然还有一种更优雅的处理加减的方式：</p><div class="code-wrapper"><pre><code class="hljs">表达式 = 项 + 项 + 项项 = +/- (因子 */ 因子 */ 因子)</code></pre></div><p>这样一来，在项结算的时候乘以1或-1，于是表达式只需要无脑加就可以了，思维量减小不少。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span><br>&#123;<br>    <span class="hljs-comment">//……</span><br>        <span class="hljs-comment">//如果发现是减</span><br>        <span class="hljs-keyword">return</span> num * sign + cal(<span class="hljs-number">-1</span>);<span class="hljs-comment">//传入的参数就是sign</span><br>    <span class="hljs-comment">//……</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>再优雅一点，可以把重复使用功能写成一个函数，比如下文的getNum()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> sign)</span> <span class="hljs-comment">//用sign来标记这一项是正是负，也就是它的前面是加是减</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp;<br><span class="hljs-type">int</span> flag; <span class="hljs-comment">//用来标记计算方式， 1 为 * , 2 为 /</span><br><br><span class="hljs-comment">//项的开头必然是数字，所以先赋值一个数字</span><br>num = getNum();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//收尾部分：如果这一项结束了，进入收尾代码</span><br><br>        <span class="hljs-comment">//收尾代码</span><br><br><span class="hljs-comment">//循环部分：各种乘除</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[step]))<br>&#123;<br>tmp = getNum();<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>num *= tmp;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>num /= tmp;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">1</span>;<br>            step++;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[step] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-number">2</span>;<br>            step++;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题有一点难想的部分可能就是：如何在获得因子之后，知道它与前面数字的计算是乘是除。代码中已经给了一个还不错的方法。</p><p>每进一步，都及时地进行计算，这样拿在手上的数字就不会太多，也会比较好想。</p><p>要是还想再优雅一点，由于项对每个因子的计算都是乘法/除法，而1*任何数字还是其本身，所以可以不为项的第一个因子写getNum()，而直接进入“标准化作业”。想想看怎么写吧。</p><p>掌握对表达式的层次化理解，非常有助于自己编程思维的形成。以后必然会出现涉及括号的表达式计算，有兴趣的同学也可以想想要怎么实现。</p><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><p>就是模拟竖式减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C">    <span class="hljs-type">void</span> <span class="hljs-title function_">jian</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> l1 = <span class="hljs-built_in">strlen</span>(s);    <span class="hljs-comment">//字符串长度 </span><br>    <span class="hljs-type">int</span> l2 = <span class="hljs-built_in">strlen</span>(ss);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;         <span class="hljs-comment">//一个记录正负的变量（后面就知道啦） </span><br><br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));       <br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));  <br><br>    <span class="hljs-keyword">if</span> ( l1 &lt; l2 || (<span class="hljs-built_in">strcmp</span>(s,ss) &lt; <span class="hljs-number">0</span> &amp;&amp; l1 == l2) )    <span class="hljs-comment">//这个比较重要是来判断前后两数的大小的  </span><br>    &#123;                                           <span class="hljs-comment">//不然一个小的数减一个大的数是大于零的就尴尬了</span><br>        flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里是把正负记录下来  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)    <span class="hljs-comment">//倒过来输入 </span><br>            a[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;      <span class="hljs-comment">//将字符串里的字符转换为数字 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l1 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)   <span class="hljs-comment">//同理，倒过来输入 </span><br>            a[l1 - i - <span class="hljs-number">1</span>] = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l2 - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i--)<br>            b[l2 - i - <span class="hljs-number">1</span>] = ss[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 &gt; l2) <br>        len = l1;             <span class="hljs-comment">//len赋值为其中大的数 </span><br>    <span class="hljs-keyword">else</span> <br>        len = l2; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++)<br>    &#123;<br>        a[i] = a[i] - b[i];     <span class="hljs-comment">//运算 </span><br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">//如果减得多了 </span><br>        &#123;<br>            a[i+<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span>;         <span class="hljs-comment">//向前要一位 </span><br>            a[i]+=<span class="hljs-number">10</span>;          <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (a[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; len&gt;<span class="hljs-number">1</span>) len--;   <span class="hljs-comment">//while去零法，了解一下（名字现编的，别搜百度了） 这个&amp;&amp;len&gt;1 很重要，防止结果为0 不输出。</span><br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);     <span class="hljs-comment">//如果结果是负的，先输出一个负号 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span> ;i &gt;= <span class="hljs-number">0</span> ;i--)   <span class="hljs-comment">//再输出结果 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);   <span class="hljs-comment">//换行 </span><br>&#125;                           <span class="hljs-comment">//高精度减法你懂了吗？ </span><br></code></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>把求全排列想象成：手上有 1~n n张数字卡片，依次放入编号为1~n的盒子里面。用book[]数组记录某个卡片是否被使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">fullArray(<span class="hljs-type">int</span> step, <span class="hljs-type">int</span> n)<br>&#123;<br><br>    <span class="hljs-comment">//收尾情况的代码：盒子放满后，进入收尾代码</span><br>    <span class="hljs-comment">//收尾代码：逐一打印数字卡片</span><br><br>    <span class="hljs-comment">//递归部分的代码：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//每一步都从最小的开始尝试放数字</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (book[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">//如果还没有被用</span><br>        &#123;<br>            a[step] = i;      <span class="hljs-comment">//用一个数组装卡片，放下数字卡片</span><br>            book[i] = <span class="hljs-number">1</span>;      <span class="hljs-comment">//表明放下的数字卡片被占用</span><br>            fullArray(step + <span class="hljs-number">1</span>, n); <span class="hljs-comment">//开始下一步</span><br>            book[i] = <span class="hljs-number">0</span>;      <span class="hljs-comment">//取回数字卡片</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于官方数字量不大，非要打表也不是不行（误）。</p><p>看到这里，就关掉网页自己写一遍吧。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0. 开始</title>
    <link href="/2022/02/26/beginning/"/>
    <url>/2022/02/26/beginning/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>数据结构系列博客 旨在帮助北航2022信息类数据结构课的同学们，提供（与CSDN相比）质量较好的代码。博客内容包含数据结构中涉及的算法、数据结构模板，以及部分知识的讲解，并提供<del>充分的</del>注释以供同学们参考学习。  </p><p>代码主要来自个人作业以及个人笔记，且本人水平有限，代码风格欠佳，故不保证正确性，如发现有问题，或有更好的补充，欢迎在评论区指正，本人必及时修改。</p><p>本博客与课程进度（大概）同步更新。</p><h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><ol><li>数据结构课的作业、考试均在自己的电脑上完成，所以非常建议大家转用vs code，界面好看功能多，调试更友好。</li><li> vs code 下，ctrl＋alt＋F（dev C++ 下，ctrl＋shift<br>＋A）可以格式化代码，让代码更好读，也有助于助教解答。</li><li>judge平台可以进行在线答疑，会有助教轮班解答。</li><li>推荐书籍：《啊哈算法》、《大话数据结构》，两本书基本覆盖数据结构课程内容。</li><li>数据结构的题目都很经典，一般在网上就可以找到完全匹配的算法。所以实在不会可以试着百度一下题干。</li></ol><h1 id="特别警告"><a href="#特别警告" class="headerlink" title="特别警告"></a>特别警告</h1><p>数据结构课程组<strong>十分重视抄袭问题！系统会对提交的代码进行查重！</strong>故<strong>万万不可复制博客中的代码</strong>，也尽量不要对着博客写代码，防止被 认定/误认定 为抄袭。博客中的代码仅供参考，作业中的代码烦请自行书写。</p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
